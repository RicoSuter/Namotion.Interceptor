using System.Linq;
using System.Text;
using Namotion.Interceptor.Generator.Models;

namespace Namotion.Interceptor.Generator;

internal static class SubjectCodeGenerator
{
    /// <summary>
    /// Generates the C# code for an interceptor subject class.
    /// </summary>
    public static string Generate(SubjectMetadata metadata)
    {
        var builder = new StringBuilder();

        EmitFileHeader(builder);
        EmitNamespaceOpening(builder, metadata.NamespaceName);
        EmitContainingTypeOpening(builder, metadata.ContainingTypes);
        EmitClassDeclaration(builder, metadata);
        EmitNotifyPropertyChangedImplementation(builder, metadata.BaseClassHasInpc);
        EmitInterceptorSubjectImplementation(builder, metadata);
        EmitPropertyAccessors(builder, metadata);
        EmitConstructors(builder, metadata);
        EmitProperties(builder, metadata);
        EmitMethods(builder, metadata);
        EmitHelperMethods(builder);
        EmitClassClosing(builder);
        EmitContainingTypeClosing(builder, metadata.ContainingTypes);
        EmitNamespaceClosing(builder);

        return builder.ToString();
    }

    /// <summary>
    /// Generates the filename for the generated code.
    /// </summary>
    public static string GetFileName(SubjectMetadata metadata)
    {
        var containingTypesPath = metadata.ContainingTypes.Length > 0
            ? string.Join(".", metadata.ContainingTypes) + "."
            : "";
        return $"{metadata.NamespaceName}.{containingTypesPath}{metadata.ClassName}.g.cs";
    }

    private static void EmitFileHeader(StringBuilder builder)
    {
        builder.Append("""
            // <auto-generated>
            //     This code was generated by Namotion.Interceptor.Generator
            // </auto-generated>

            using Namotion.Interceptor;
            using Namotion.Interceptor.Interceptors;

            using System;
            using System.Collections.Concurrent;
            using System.Collections.Generic;
            using System.Collections.Frozen;
            using System.ComponentModel;
            using System.Linq;
            using System.Reflection;
            using System.Runtime.CompilerServices;
            using System.Text.Json.Serialization;

            #pragma warning disable CS8669
            #pragma warning disable CS0649
            #pragma warning disable CS0067


            """);
    }

    private static void EmitNamespaceOpening(StringBuilder builder, string namespaceName)
    {
        builder.AppendLine($"namespace {namespaceName}");
        builder.AppendLine("{");
    }

    private static void EmitNamespaceClosing(StringBuilder builder)
    {
        builder.AppendLine("}");
    }

    private static void EmitContainingTypeOpening(StringBuilder builder, string[] containingTypes)
    {
        foreach (var type in containingTypes)
        {
            builder.AppendLine($"    partial class {type}");
            builder.AppendLine("    {");
        }
    }

    private static void EmitContainingTypeClosing(StringBuilder builder, string[] containingTypes)
    {
        foreach (var _ in containingTypes)
        {
            builder.AppendLine("    }");
        }
    }

    private static void EmitClassDeclaration(StringBuilder builder, SubjectMetadata metadata)
    {
        var interfaces = metadata.BaseClassHasInpc
            ? "IInterceptorSubject"
            : "IInterceptorSubject, INotifyPropertyChanged, IRaisePropertyChanged";

        builder.AppendLine($"    public partial class {metadata.ClassName} : {interfaces}");
        builder.AppendLine("    {");
    }

    private static void EmitClassClosing(StringBuilder builder)
    {
        builder.AppendLine("    }");
    }

    private static void EmitNotifyPropertyChangedImplementation(StringBuilder builder, bool baseClassHasInpc)
    {
        if (baseClassHasInpc)
        {
            return;
        }

        builder.Append("""
                    public event PropertyChangedEventHandler? PropertyChanged;

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    protected void RaisePropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, PropertyChangedEventArgsCache.Get(propertyName));

                    void IRaisePropertyChanged.RaisePropertyChanged(string propertyName) => RaisePropertyChanged(propertyName);


            """);
    }

    private static void EmitInterceptorSubjectImplementation(StringBuilder builder, SubjectMetadata metadata)
    {
        builder.Append($$"""
                    private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::Namotion.Interceptor.SubjectPropertyMetadata> __defaultProperties =
                        global::Namotion.Interceptor.SubjectPropertyMetadataCache.Get<{{metadata.ClassName}}>();

                    private IInterceptorExecutor? _context;
                    private IReadOnlyDictionary<string, SubjectPropertyMetadata>? _properties;

                    [JsonIgnore]
                    IInterceptorSubjectContext IInterceptorSubject.Context => _context ??= new InterceptorExecutor(this);

                    [JsonIgnore]
                    ConcurrentDictionary<(string? property, string key), object?> IInterceptorSubject.Data { get; } = new();

                    [JsonIgnore]
                    global::System.Collections.Generic.IReadOnlyDictionary<string, global::Namotion.Interceptor.SubjectPropertyMetadata> global::Namotion.Interceptor.IInterceptorSubject.Properties =>
                        _properties ?? __defaultProperties;

                    [JsonIgnore]
                    object IInterceptorSubject.SyncRoot { get; } = new object();

                    void global::Namotion.Interceptor.IInterceptorSubject.AddProperties(params global::System.Collections.Generic.IEnumerable<global::Namotion.Interceptor.SubjectPropertyMetadata> properties)
                    {
                        _properties = (_properties ?? __defaultProperties)
                            .Concat(properties.Select(p => new global::System.Collections.Generic.KeyValuePair<string, global::Namotion.Interceptor.SubjectPropertyMetadata>(p.Name, p)))
                            .ToFrozenDictionary();
                    }


            """);
    }

    private static void EmitPropertyAccessors(StringBuilder builder, SubjectMetadata metadata)
    {
        // Use 'new' modifier if base class also has [InterceptorSubject] to hide inherited method
        var newModifier = metadata.BaseClassHasInterceptorSubject ? "new " : "";

        builder.AppendLine();
        builder.AppendLine("        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        builder.AppendLine($"        internal static {newModifier}(global::System.Func<global::Namotion.Interceptor.IInterceptorSubject, object?>?, global::System.Action<global::Namotion.Interceptor.IInterceptorSubject, object?>?)");
        builder.AppendLine("            __GetPropertyAccessors(string name) => name switch");
        builder.AppendLine("        {");

        foreach (var property in metadata.Properties)
        {
            // InterfaceTypeName already contains "global::" prefix from FullyQualifiedFormat
            var typeCast = property.IsFromInterface && property.InterfaceTypeName != null
                ? property.InterfaceTypeName
                : metadata.ClassName;

            var getter = property.HasGetter
                ? $"static o => (({typeCast})o).{property.Name}"
                : "null";

            var setter = property.HasSetter && !property.IsFromInterface
                ? $"static (o, v) => (({metadata.ClassName})o).{property.Name} = ({property.FullTypeName})v!"
                : "null";

            builder.AppendLine($"            \"{property.Name}\" => ({getter}, {setter}),");
        }

        builder.AppendLine("            _ => (null, null)");
        builder.AppendLine("        };");
    }

    private static void EmitConstructors(StringBuilder builder, SubjectMetadata metadata)
    {
        // Generate parameterless constructor only if no constructor exists
        if (metadata.NeedsGeneratedParameterlessConstructor)
        {
            builder.AppendLine($"        public {metadata.ClassName}()");
            builder.AppendLine("        {");
            builder.AppendLine("        }");
            builder.AppendLine();
        }

        // Generate constructor with context parameter if we have or will have a parameterless constructor
        if (metadata.HasOrWillHaveParameterlessConstructor)
        {
            builder.AppendLine($"        public {metadata.ClassName}(IInterceptorSubjectContext context) : this()");
            builder.AppendLine("        {");
            builder.AppendLine("            ((IInterceptorSubject)this).Context.AddFallbackContext(context);");
            builder.AppendLine("        }");
            builder.AppendLine();
        }
    }

    private static void EmitProperties(StringBuilder builder, SubjectMetadata metadata)
    {
        foreach (var property in metadata.Properties.Where(p => p.IsPartial))
        {
            EmitProperty(builder, property, metadata);
        }
    }

    private static void EmitProperty(StringBuilder builder, PropertyMetadata property, SubjectMetadata metadata)
    {
        // Backing field
        builder.AppendLine($"        private {property.FullTypeName} _{property.Name};");
        builder.AppendLine();

        // Build modifiers
        var additionalModifiers = "";
        if (property.IsVirtual)
        {
            additionalModifiers = "virtual ";
        }
        else if (property.IsOverride)
        {
            additionalModifiers = "override ";
        }

        var requiredModifier = property.IsRequired ? "required " : "";

        builder.AppendLine("        [global::Namotion.Interceptor.Attributes.Intercepted]");
        builder.AppendLine($"        {property.AccessModifier} {requiredModifier}{additionalModifiers}partial {property.FullTypeName} {property.Name}");
        builder.AppendLine("        {");

        // Getter
        if (property.HasGetter)
        {
            var getterModifiers = property.GetterAccessModifier is not null ? $"{property.GetterAccessModifier} " : "";
            builder.AppendLine($"            {getterModifiers}get");
            builder.AppendLine("            {");
            builder.AppendLine($"                return GetPropertyValue<{property.FullTypeName}>(nameof({property.Name}), static (o) => (({metadata.ClassName})o)._{property.Name});");
            builder.AppendLine("            }");
        }

        // Setter or Init
        if (property.HasSetter || property.HasInit)
        {
            var accessorText = property.HasInit ? "init" : "set";
            var setterModifiers = property.SetterAccessModifier is not null ? $"{property.SetterAccessModifier} " : "";

            // Determine how to call RaisePropertyChanged:
            // - [InterceptorSubject] base: direct call to inherited protected method (fastest)
            // - Manual IRaisePropertyChanged base: interface cast (rare case)
            // - Own implementation: direct call to own method (fastest)
            var raisePropertyChangedCall = metadata.BaseClassHasInterceptorSubject
                ? $"RaisePropertyChanged(nameof({property.Name}))"
                : metadata.BaseClassHasInpc
                    ? $"((IRaisePropertyChanged)this).RaisePropertyChanged(nameof({property.Name}))"
                    : $"RaisePropertyChanged(nameof({property.Name}))";

            builder.AppendLine($"            {setterModifiers}{accessorText}");
            builder.AppendLine("            {");
            builder.AppendLine("                var newValue = value;");
            builder.AppendLine("                var cancel = false;");
            builder.AppendLine($"                On{property.Name}Changing(ref newValue, ref cancel);");
            builder.AppendLine($"                if (!cancel && SetPropertyValue(nameof({property.Name}), newValue, static (o) => (({metadata.ClassName})o)._{property.Name}, static (o, v) => (({metadata.ClassName})o)._{property.Name} = v))");
            builder.AppendLine("                {");
            builder.AppendLine($"                    On{property.Name}Changed(_{property.Name});");
            builder.AppendLine($"                    {raisePropertyChangedCall};");
            builder.AppendLine("                }");
            builder.AppendLine("            }");
        }

        builder.AppendLine("        }");
        builder.AppendLine();

        // Partial method hooks
        if (property.HasSetter || property.HasInit)
        {
            builder.AppendLine($"        partial void On{property.Name}Changing(ref {property.FullTypeName} newValue, ref bool cancel);");
            builder.AppendLine();
            builder.AppendLine($"        partial void On{property.Name}Changed({property.FullTypeName} newValue);");
            builder.AppendLine();
        }
    }

    private static void EmitMethods(StringBuilder builder, SubjectMetadata metadata)
    {
        foreach (var method in metadata.Methods)
        {
            EmitMethod(builder, method, metadata);
        }
    }

    private static void EmitMethod(StringBuilder builder, MethodMetadata method, SubjectMetadata metadata)
    {
        var parameterDeclarations = string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"));
        var directParameterCode = string.Join(", ", method.Parameters.Select((p, i) => $"({p.Type})p[{i}]!"));
        var invokeParameterCode = method.Parameters.Any()
            ? ", " + string.Join(", ", method.Parameters.Select(p => p.Name))
            : "";

        if (method.ReturnType != "void")
        {
            builder.AppendLine($"        public {method.ReturnType} {method.Name}({parameterDeclarations})");
            builder.AppendLine("        {");
            builder.AppendLine($"            return ({method.ReturnType})InvokeMethod(\"{method.Name}\", static (s, p) => (({metadata.ClassName})s).{method.FullMethodName}({directParameterCode}){invokeParameterCode})!;");
            builder.AppendLine("        }");
        }
        else
        {
            builder.AppendLine($"        public {method.ReturnType} {method.Name}({parameterDeclarations})");
            builder.AppendLine("        {");
            builder.AppendLine($"            InvokeMethod(\"{method.Name}\", static (s, p) => {{ (({metadata.ClassName})s).{method.FullMethodName}({directParameterCode}); return null; }}{invokeParameterCode});");
            builder.AppendLine("        }");
        }

        builder.AppendLine();
    }

    private static void EmitHelperMethods(StringBuilder builder)
    {
        builder.Append("""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    private TProperty GetPropertyValue<TProperty>(string propertyName, Func<IInterceptorSubject, TProperty> readValue)
                    {
                        return _context is not null ? _context.GetPropertyValue(propertyName, readValue)! : readValue(this)!;
                    }

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    private bool SetPropertyValue<TProperty>(string propertyName, TProperty newValue, Func<IInterceptorSubject, TProperty> readValue, Action<IInterceptorSubject, TProperty> setValue)
                    {
                        if (_context is null)
                        {
                            setValue(this, newValue);
                            return true;
                        }
                        else
                        {
                            return _context.SetPropertyValue(propertyName, newValue, readValue, setValue);
                        }
                    }

                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    private object? InvokeMethod(string methodName, Func<IInterceptorSubject, object?[], object?> invokeMethod, params object?[] parameters)
                    {
                        return _context is not null ? _context.InvokeMethod(methodName, parameters, invokeMethod) : invokeMethod(this, parameters);
                    }

            """);
    }
}
