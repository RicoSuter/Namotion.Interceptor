using System.Linq;
using System.Text;
using Namotion.Interceptor.Generator.Models;

namespace Namotion.Interceptor.Generator;

internal static class SubjectCodeGenerator
{
    /// <summary>
    /// Generates the C# code for an interceptor subject class.
    /// </summary>
    public static string Generate(SubjectMetadata metadata)
    {
        var builder = new StringBuilder();

        EmitFileHeader(builder);
        EmitNamespaceOpening(builder, metadata.NamespaceName);
        EmitContainingTypeOpening(builder, metadata.ContainingTypes);
        EmitClassDeclaration(builder, metadata);
        EmitNotifyPropertyChangedImplementation(builder, metadata.BaseClassHasInpc);
        EmitInterceptorSubjectImplementation(builder, metadata);
        EmitDefaultProperties(builder, metadata);
        EmitConstructors(builder, metadata);
        EmitProperties(builder, metadata);
        EmitMethods(builder, metadata);
        EmitHelperMethods(builder);
        EmitClassClosing(builder);
        EmitContainingTypeClosing(builder, metadata.ContainingTypes);
        EmitNamespaceClosing(builder);

        return builder.ToString();
    }

    /// <summary>
    /// Generates the filename for the generated code.
    /// </summary>
    public static string GetFileName(SubjectMetadata metadata)
    {
        var containingTypesPath = metadata.ContainingTypes.Length > 0
            ? string.Join(".", metadata.ContainingTypes) + "."
            : "";
        return $"{metadata.NamespaceName}.{containingTypesPath}{metadata.ClassName}.g.cs";
    }

    private static void EmitFileHeader(StringBuilder builder)
    {
        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("//     This code was generated by Namotion.Interceptor.Generator");
        builder.AppendLine("// </auto-generated>");
        builder.AppendLine();
        builder.AppendLine("using Namotion.Interceptor;");
        builder.AppendLine("using Namotion.Interceptor.Interceptors;");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Concurrent;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Collections.Frozen;");
        builder.AppendLine("using System.ComponentModel;");
        builder.AppendLine("using System.Linq;");
        builder.AppendLine("using System.Reflection;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine("using System.Text.Json.Serialization;");
        builder.AppendLine();
        builder.AppendLine("#pragma warning disable CS8669");
        builder.AppendLine("#pragma warning disable CS0649");
        builder.AppendLine("#pragma warning disable CS0067");
        builder.AppendLine();
    }

    private static void EmitNamespaceOpening(StringBuilder builder, string namespaceName)
    {
        builder.AppendLine($"namespace {namespaceName}");
        builder.AppendLine("{");
    }

    private static void EmitNamespaceClosing(StringBuilder builder)
    {
        builder.AppendLine("}");
    }

    private static void EmitContainingTypeOpening(StringBuilder builder, string[] containingTypes)
    {
        foreach (var type in containingTypes)
        {
            builder.AppendLine($"    partial class {type}");
            builder.AppendLine("    {");
        }
    }

    private static void EmitContainingTypeClosing(StringBuilder builder, string[] containingTypes)
    {
        foreach (var _ in containingTypes)
        {
            builder.AppendLine("    }");
        }
    }

    private static void EmitClassDeclaration(StringBuilder builder, SubjectMetadata metadata)
    {
        var interfaces = metadata.BaseClassHasInpc
            ? "IInterceptorSubject"
            : "IInterceptorSubject, INotifyPropertyChanged, IRaisePropertyChanged";

        builder.AppendLine($"    public partial class {metadata.ClassName} : {interfaces}");
        builder.AppendLine("    {");
    }

    private static void EmitClassClosing(StringBuilder builder)
    {
        builder.AppendLine("    }");
    }

    private static void EmitNotifyPropertyChangedImplementation(StringBuilder builder, bool baseClassHasInpc)
    {
        if (baseClassHasInpc)
        {
            return;
        }

        builder.AppendLine("        public event PropertyChangedEventHandler? PropertyChanged;");
        builder.AppendLine();
        builder.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.AppendLine("        protected void RaisePropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, PropertyChangedEventArgsCache.Get(propertyName));");
        builder.AppendLine();
        builder.AppendLine("        void IRaisePropertyChanged.RaisePropertyChanged(string propertyName) => RaisePropertyChanged(propertyName);");
        builder.AppendLine();
    }

    private static void EmitInterceptorSubjectImplementation(StringBuilder builder, SubjectMetadata metadata)
    {
        builder.AppendLine("        private IInterceptorExecutor? _context;");
        builder.AppendLine("        private IReadOnlyDictionary<string, SubjectPropertyMetadata>? _properties;");
        builder.AppendLine();
        builder.AppendLine("        [JsonIgnore]");
        builder.AppendLine("        IInterceptorSubjectContext IInterceptorSubject.Context => _context ??= new InterceptorExecutor(this);");
        builder.AppendLine();
        builder.AppendLine("        [JsonIgnore]");
        builder.AppendLine("        ConcurrentDictionary<(string? property, string key), object?> IInterceptorSubject.Data { get; } = new();");
        builder.AppendLine();
        builder.AppendLine("        [JsonIgnore]");
        builder.AppendLine("        IReadOnlyDictionary<string, SubjectPropertyMetadata> IInterceptorSubject.Properties => _properties ?? DefaultProperties;");
        builder.AppendLine();
        builder.AppendLine("        [JsonIgnore]");
        builder.AppendLine("        object IInterceptorSubject.SyncRoot { get; } = new object();");
        builder.AppendLine();
        builder.AppendLine("        void IInterceptorSubject.AddProperties(params IEnumerable<SubjectPropertyMetadata> properties)");
        builder.AppendLine("        {");
        builder.AppendLine("            _properties = (_properties ?? DefaultProperties)");
        builder.AppendLine("                .Concat(properties.Select(p => new KeyValuePair<string, SubjectPropertyMetadata>(p.Name, p)))");
        builder.AppendLine("                .ToFrozenDictionary();");
        builder.AppendLine("        }");
        builder.AppendLine();
    }

    private static void EmitDefaultProperties(StringBuilder builder, SubjectMetadata metadata)
    {
        var newModifier = metadata.BaseClassTypeName is not null ? "new " : "";

        builder.AppendLine($"        public {newModifier}static IReadOnlyDictionary<string, SubjectPropertyMetadata> DefaultProperties {{ get; }} =");
        builder.AppendLine("            new Dictionary<string, SubjectPropertyMetadata>");
        builder.AppendLine("            {");

        foreach (var property in metadata.Properties)
        {
            if (property.IsFromInterface)
            {
                // Interface default properties: cast to interface to invoke default implementation
                var getterLambda = property.HasGetter
                    ? $"(o) => (({property.InterfaceTypeName})o).{property.Name}"
                    : "null";
                // Interface default properties are read-only (no setter)
                var setterLambda = "null";

                builder.AppendLine("                {");
                builder.AppendLine($"                    \"{property.Name}\",");
                builder.AppendLine("                    new SubjectPropertyMetadata(");
                builder.AppendLine($"                        typeof({property.InterfaceTypeName}).GetProperty(nameof({property.InterfaceTypeName}.{property.Name}), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)!,");
                builder.AppendLine($"                        {getterLambda},");
                builder.AppendLine($"                        {setterLambda},");
                builder.AppendLine("                        isIntercepted: false,");
                builder.AppendLine("                        isDynamic: false)");
                builder.AppendLine("                },");
            }
            else
            {
                var getterLambda = property.HasGetter
                    ? $"(o) => (({metadata.ClassName})o).{property.Name}"
                    : "null";
                // Note: init-only properties cannot have a setter lambda because they can only be set during construction
                var setterLambda = property.HasSetter
                    ? $"(o, v) => (({metadata.ClassName})o).{property.Name} = ({property.FullTypeName})v"
                    : "null";

                builder.AppendLine("                {");
                builder.AppendLine($"                    \"{property.Name}\",");
                builder.AppendLine("                    new SubjectPropertyMetadata(");
                builder.AppendLine($"                        typeof({metadata.ClassName}).GetProperty(nameof({property.Name}), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)!,");
                builder.AppendLine($"                        {getterLambda},");
                builder.AppendLine($"                        {setterLambda},");
                builder.AppendLine($"                        isIntercepted: {(property.IsPartial ? "true" : "false")},");
                builder.AppendLine("                        isDynamic: false)");
                builder.AppendLine("                },");
            }
        }

        builder.AppendLine("            }");

        if (metadata.BaseClassTypeName is not null)
        {
            builder.AppendLine($"            .Concat({metadata.BaseClassTypeName}.DefaultProperties)");
        }

        builder.AppendLine("            .ToFrozenDictionary();");
        builder.AppendLine();
    }

    private static void EmitConstructors(StringBuilder builder, SubjectMetadata metadata)
    {
        // Generate parameterless constructor only if no constructor exists
        if (metadata.NeedsGeneratedParameterlessConstructor)
        {
            builder.AppendLine($"        public {metadata.ClassName}()");
            builder.AppendLine("        {");
            builder.AppendLine("        }");
            builder.AppendLine();
        }

        // Generate constructor with context parameter if we have or will have a parameterless constructor
        if (metadata.HasOrWillHaveParameterlessConstructor)
        {
            builder.AppendLine($"        public {metadata.ClassName}(IInterceptorSubjectContext context) : this()");
            builder.AppendLine("        {");
            builder.AppendLine("            ((IInterceptorSubject)this).Context.AddFallbackContext(context);");
            builder.AppendLine("        }");
            builder.AppendLine();
        }
    }

    private static void EmitProperties(StringBuilder builder, SubjectMetadata metadata)
    {
        foreach (var property in metadata.Properties.Where(p => p.IsPartial))
        {
            EmitProperty(builder, property, metadata);
        }
    }

    private static void EmitProperty(StringBuilder builder, PropertyMetadata property, SubjectMetadata metadata)
    {
        // Backing field
        builder.AppendLine($"        private {property.FullTypeName} _{property.Name};");
        builder.AppendLine();

        // Build modifiers
        var additionalModifiers = "";
        if (property.IsVirtual)
        {
            additionalModifiers = "virtual ";
        }
        else if (property.IsOverride)
        {
            additionalModifiers = "override ";
        }

        var requiredModifier = property.IsRequired ? "required " : "";

        builder.AppendLine($"        {property.AccessModifier} {requiredModifier}{additionalModifiers}partial {property.FullTypeName} {property.Name}");
        builder.AppendLine("        {");

        // Getter
        if (property.HasGetter)
        {
            var getterModifiers = property.GetterAccessModifier is not null ? $"{property.GetterAccessModifier} " : "";
            builder.AppendLine($"            {getterModifiers}get");
            builder.AppendLine("            {");
            builder.AppendLine($"                return GetPropertyValue<{property.FullTypeName}>(nameof({property.Name}), static (o) => (({metadata.ClassName})o)._{property.Name});");
            builder.AppendLine("            }");
        }

        // Setter or Init
        if (property.HasSetter || property.HasInit)
        {
            var accessorText = property.HasInit ? "init" : "set";
            var setterModifiers = property.SetterAccessModifier is not null ? $"{property.SetterAccessModifier} " : "";

            // Determine how to call RaisePropertyChanged
            // - [InterceptorSubject] base or own implementation: direct call to protected method
            // - Manual IRaisePropertyChanged base: interface cast
            var raisePropertyChangedCall = metadata.BaseClassHasInpc && metadata.BaseClassTypeName is not null
                ? $"((IRaisePropertyChanged)this).RaisePropertyChanged(nameof({property.Name}))"
                : $"RaisePropertyChanged(nameof({property.Name}))";

            // Actually, looking at the original code more carefully:
            // HasInterceptorSubjectAttribute(baseClass) => direct call
            // baseClassHasInpc but not HasInterceptorSubjectAttribute => interface cast
            // Own implementation => direct call
            // Since we don't have HasInterceptorSubjectAttribute info separately, we'll use BaseClassHasInpc
            // When BaseClassHasInpc is true AND BaseClassTypeName exists, it could be either case
            // The safest approach: if no base class, direct call; otherwise interface cast when baseClassHasInpc
            if (metadata.BaseClassTypeName is null)
            {
                raisePropertyChangedCall = $"RaisePropertyChanged(nameof({property.Name}))";
            }

            builder.AppendLine($"            {setterModifiers}{accessorText}");
            builder.AppendLine("            {");
            builder.AppendLine("                var newValue = value;");
            builder.AppendLine("                var cancel = false;");
            builder.AppendLine($"                On{property.Name}Changing(ref newValue, ref cancel);");
            builder.AppendLine($"                if (!cancel && SetPropertyValue(nameof({property.Name}), newValue, static (o) => (({metadata.ClassName})o)._{property.Name}, static (o, v) => (({metadata.ClassName})o)._{property.Name} = v))");
            builder.AppendLine("                {");
            builder.AppendLine($"                    On{property.Name}Changed(_{property.Name});");
            builder.AppendLine($"                    {raisePropertyChangedCall};");
            builder.AppendLine("                }");
            builder.AppendLine("            }");
        }

        builder.AppendLine("        }");
        builder.AppendLine();

        // Partial method hooks
        if (property.HasSetter || property.HasInit)
        {
            builder.AppendLine($"        partial void On{property.Name}Changing(ref {property.FullTypeName} newValue, ref bool cancel);");
            builder.AppendLine();
            builder.AppendLine($"        partial void On{property.Name}Changed({property.FullTypeName} newValue);");
            builder.AppendLine();
        }
    }

    private static void EmitMethods(StringBuilder builder, SubjectMetadata metadata)
    {
        foreach (var method in metadata.Methods)
        {
            EmitMethod(builder, method, metadata);
        }
    }

    private static void EmitMethod(StringBuilder builder, MethodMetadata method, SubjectMetadata metadata)
    {
        var parameterDeclarations = string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"));
        var directParameterCode = string.Join(", ", method.Parameters.Select((p, i) => $"({p.Type})p[{i}]!"));
        var invokeParameterCode = method.Parameters.Any()
            ? ", " + string.Join(", ", method.Parameters.Select(p => p.Name))
            : "";

        if (method.ReturnType != "void")
        {
            builder.AppendLine($"        public {method.ReturnType} {method.Name}({parameterDeclarations})");
            builder.AppendLine("        {");
            builder.AppendLine($"            return ({method.ReturnType})InvokeMethod(\"{method.Name}\", static (s, p) => (({metadata.ClassName})s).{method.FullMethodName}({directParameterCode}){invokeParameterCode})!;");
            builder.AppendLine("        }");
        }
        else
        {
            builder.AppendLine($"        public {method.ReturnType} {method.Name}({parameterDeclarations})");
            builder.AppendLine("        {");
            builder.AppendLine($"            InvokeMethod(\"{method.Name}\", static (s, p) => {{ (({metadata.ClassName})s).{method.FullMethodName}({directParameterCode}); return null; }}{invokeParameterCode});");
            builder.AppendLine("        }");
        }

        builder.AppendLine();
    }

    private static void EmitHelperMethods(StringBuilder builder)
    {
        builder.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.AppendLine("        private TProperty GetPropertyValue<TProperty>(string propertyName, Func<IInterceptorSubject, TProperty> readValue)");
        builder.AppendLine("        {");
        builder.AppendLine("            return _context is not null ? _context.GetPropertyValue(propertyName, readValue)! : readValue(this)!;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.AppendLine("        private bool SetPropertyValue<TProperty>(string propertyName, TProperty newValue, Func<IInterceptorSubject, TProperty> readValue, Action<IInterceptorSubject, TProperty> setValue)");
        builder.AppendLine("        {");
        builder.AppendLine("            if (_context is null)");
        builder.AppendLine("            {");
        builder.AppendLine("                setValue(this, newValue);");
        builder.AppendLine("                return true;");
        builder.AppendLine("            }");
        builder.AppendLine("            else");
        builder.AppendLine("            {");
        builder.AppendLine("                return _context.SetPropertyValue(propertyName, newValue, readValue, setValue);");
        builder.AppendLine("            }");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.AppendLine("        private object? InvokeMethod(string methodName, Func<IInterceptorSubject, object?[], object?> invokeMethod, params object?[] parameters)");
        builder.AppendLine("        {");
        builder.AppendLine("            return _context is not null ? _context.InvokeMethod(methodName, parameters, invokeMethod) : invokeMethod(this, parameters);");
        builder.AppendLine("        }");
    }
}
