@using HomeBlaze.Abstractions
@using HomeBlaze.Abstractions.Components
@using HomeBlaze.Core.Extensions
@using HomeBlaze.Core.Services
@using Microsoft.AspNetCore.Components.Rendering
@using Namotion.Interceptor
@using Namotion.Interceptor.Registry
@using Namotion.Interceptor.Registry.Abstractions
@using Namotion.Interceptor.Tracking
@implements IDisposable
@inject RootManager RootManager
@inject SubjectComponentRegistry ComponentRegistry

<MudDialog>
    <DialogContent>
        @if (Subject != null)
        {
            @if (_editComponentType != null)
            {
                <DynamicComponent Type="_editComponentType"
                    @ref="_dynamicComponentRef"
                    Parameters="@(new Dictionary<string, object?> { ["Subject"] = Subject })" />
            }
            else if (_configProperties.Any())
            {
                @if (_externalChangeDetected)
                {
                    <MudAlert Severity="Severity.Warning" Class="mb-3">
                        Configuration was changed externally. Your unsaved changes may be overwritten.
                    </MudAlert>
                }
                <MudForm @ref="_form" @bind-IsValid="@_isFormValid">
                    @foreach (var prop in _configProperties)
                    {
                        @RenderPropertyEditor(prop)
                    }
                </MudForm>
            }
            else
            {
                <MudText>No configuration properties found.</MudText>
            }
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary"
                   OnClick="Save"
                   Disabled="@(!IsValid)">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    // Custom edit component state
    private Type? _editComponentType;
    private DynamicComponent? _dynamicComponentRef;
    private ISubjectEditComponent? _editComponent;

    // Fallback property editor state
    private MudForm? _form;
    private bool _isFormValid;
    private bool _isSaving;
    private bool _externalChangeDetected;
    private List<RegisteredSubjectProperty> _configProperties = new();
    private Dictionary<string, object?> _editValues = new();
    private IDisposable? _changeSubscription;

    private bool IsValid => _editComponent?.IsValid ?? _isFormValid;

    /// <summary>
    /// Gets the preferred dialog size based on the edit component.
    /// </summary>
    public MaxWidth GetPreferredDialogSize()
    {
        return _editComponent?.PreferredDialogSize ?? MaxWidth.Small;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Clean up previous subscription
        _changeSubscription?.Dispose();
        _changeSubscription = null;
        _editComponent = null;

        if (Subject != null)
        {
            // Check for custom edit component
            var registration = ComponentRegistry.GetComponent(
                Subject.GetType(),
                SubjectComponentType.Edit);

            if (registration != null)
            {
                _editComponentType = registration.ComponentType;
                _configProperties = new();
            }
            else
            {
                _editComponentType = null;

                // Use fallback property editor
                _configProperties = Subject.GetConfigurationProperties()
                    .Where(p => p.HasSetter)
                    .OrderBy(p => p.GetDisplayOrder())
                    .ToList();

                _editValues = _configProperties.ToDictionary(
                    p => p.Name,
                    p => p.GetValue());

                // Subscribe to property changes on this subject
                SubscribeToPropertyChanges();
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        // Get reference to edit component after render
        if (_dynamicComponentRef?.Instance is ISubjectEditComponent editComponent && _editComponent == null)
        {
            _editComponent = editComponent;
            _editComponent.IsValidChanged += OnIsValidChanged;
            _editComponent.IsDirtyChanged += OnIsDirtyChanged;
            StateHasChanged();
        }
    }

    private void OnIsValidChanged(bool isValid)
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnIsDirtyChanged(bool isDirty)
    {
        InvokeAsync(StateHasChanged);
    }

    private void SubscribeToPropertyChanges()
    {
        if (Subject == null) return;

        try
        {
            var observable = Subject.Context.GetPropertyChangeObservable();
            _changeSubscription = observable
                .Subscribe(
                    onNext: change =>
                    {
                        // Only care about changes to our subject's configuration properties
                        if (change.Property.Subject == Subject &&
                            !_isSaving &&
                            change.Property.TryGetRegisteredProperty()?.IsConfigurationProperty() == true)
                        {
                            _externalChangeDetected = true;
                            InvokeAsync(StateHasChanged);
                        }
                    },
                    onError: _ => { });
        }
        catch
        {
            // PropertyChangeObservable may not be registered - that's okay
        }
    }

    private RenderFragment RenderPropertyEditor(RegisteredSubjectProperty prop) => builder =>
    {
        var underlyingType = Nullable.GetUnderlyingType(prop.Type) ?? prop.Type;

        if (underlyingType == typeof(string))
        {
            RenderStringEditor(builder, prop);
        }
        else if (underlyingType == typeof(int))
        {
            RenderIntEditor(builder, prop);
        }
        else if (underlyingType == typeof(double))
        {
            RenderDoubleEditor(builder, prop);
        }
        else if (underlyingType == typeof(decimal))
        {
            RenderDecimalEditor(builder, prop);
        }
        else if (underlyingType == typeof(bool))
        {
            RenderBoolEditor(builder, prop);
        }
        else if (underlyingType == typeof(TimeSpan))
        {
            RenderTimeSpanEditor(builder, prop);
        }
        else if (underlyingType.IsEnum)
        {
            RenderEnumEditor(builder, prop, underlyingType);
        }
        else
        {
            // Fallback to string representation
            RenderStringFallbackEditor(builder, prop);
        }
    };

    private void RenderStringEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var seq = 0;
        builder.OpenComponent<MudTextField<string>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", (string?)_editValues[prop.Name]);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, value =>
        {
            _editValues[prop.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.Type));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderIntEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<int?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", _editValues[prop.Name] as int?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<int?>(this, value =>
        {
            _editValues[prop.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.Type));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderDoubleEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<double?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", _editValues[prop.Name] as double?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<double?>(this, value =>
        {
            _editValues[prop.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.Type));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderDecimalEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<decimal?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", _editValues[prop.Name] as decimal?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<decimal?>(this, value =>
        {
            _editValues[prop.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.Type));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderBoolEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var seq = 0;
        builder.OpenComponent<MudCheckBox<bool>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", _editValues[prop.Name] is bool b && b);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<bool>(this, value =>
        {
            _editValues[prop.Name] = value;
        }));
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderTimeSpanEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var value = _editValues[prop.Name];
        var timeSpan = value is TimeSpan ts ? ts : TimeSpan.Zero;
        var totalSeconds = (int)timeSpan.TotalSeconds;

        var seq = 0;
        builder.OpenComponent<MudNumericField<int>>(seq++);
        builder.AddAttribute(seq++, "Label", $"{prop.GetDisplayName()} (seconds)");
        builder.AddAttribute(seq++, "Value", totalSeconds);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<int>(this, seconds =>
        {
            _editValues[prop.Name] = TimeSpan.FromSeconds(seconds);
        }));
        builder.AddAttribute(seq++, "Min", 0);
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.Type));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderEnumEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop, Type enumType)
    {
        // For enums, use a string-based select with conversion
        var enumValues = Enum.GetValues(enumType).Cast<object>().ToList();
        var currentValue = _editValues[prop.Name];
        var currentStringValue = currentValue?.ToString() ?? "";

        var seq = 0;
        builder.OpenComponent<MudSelect<string>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.GetDisplayName());
        builder.AddAttribute(seq++, "Value", currentStringValue);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, value =>
        {
            if (!string.IsNullOrEmpty(value))
            {
                _editValues[prop.Name] = Enum.Parse(enumType, value);
            }
        }));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");

        // Add child content with enum values
        builder.AddAttribute(seq++, "ChildContent", (RenderFragment)(childBuilder =>
        {
            foreach (var enumValue in enumValues)
            {
                var strVal = enumValue.ToString() ?? "";
                childBuilder.OpenComponent<MudSelectItem<string>>(0);
                childBuilder.AddAttribute(1, "Value", strVal);
                childBuilder.AddAttribute(2, "ChildContent", (RenderFragment)(textBuilder =>
                {
                    textBuilder.AddContent(0, strVal);
                }));
                childBuilder.CloseComponent();
            }
        }));

        builder.CloseComponent();
    }

    private void RenderStringFallbackEditor(RenderTreeBuilder builder, RegisteredSubjectProperty prop)
    {
        var value = _editValues[prop.Name];
        var stringValue = value?.ToString() ?? "";

        var seq = 0;
        builder.OpenComponent<MudTextField<string>>(seq++);
        builder.AddAttribute(seq++, "Label", $"{prop.GetDisplayName()} ({prop.Type.Name})");
        builder.AddAttribute(seq++, "Value", stringValue);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, newValue =>
        {
            // Try to convert back - this is best effort
            try
            {
                var converted = Convert.ChangeType(newValue, prop.Type);
                _editValues[prop.Name] = converted;
            }
            catch
            {
                // Keep as string if conversion fails
                _editValues[prop.Name] = newValue;
            }
        }));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private static bool IsNullableType(Type type)
    {
        return Nullable.GetUnderlyingType(type) != null ||
               !type.IsValueType ||
               (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
    }

    private void Cancel() => MudDialog?.Cancel();

    private async Task Save()
    {
        if (Subject == null) return;

        _isSaving = true;
        try
        {
            if (_editComponent != null)
            {
                // Use custom edit component's save
                await _editComponent.SaveAsync();
            }
            else
            {
                // Apply all edited values to the subject using registry
                foreach (var prop in _configProperties)
                {
                    var newValue = _editValues[prop.Name];
                    var currentValue = prop.GetValue();

                    if (!Equals(newValue, currentValue))
                    {
                        try
                        {
                            // Handle type conversion if needed
                            var underlyingType = Nullable.GetUnderlyingType(prop.Type) ?? prop.Type;

                            if (newValue != null && newValue.GetType() != underlyingType)
                            {
                                newValue = Convert.ChangeType(newValue, underlyingType);
                            }

                            prop.SetValue(newValue);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Error setting {prop.Name}: {ex.Message}");
                        }
                    }
                }
            }

            // Persist the configuration to disk
            try
            {
                await RootManager.SaveAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving configuration: {ex.Message}");
            }
        }
        finally
        {
            _isSaving = false;
        }

        MudDialog?.Close(DialogResult.Ok(true));
    }

    public void Dispose()
    {
        _changeSubscription?.Dispose();

        if (_editComponent != null)
        {
            _editComponent.IsValidChanged -= OnIsValidChanged;
            _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
        }
    }
}
