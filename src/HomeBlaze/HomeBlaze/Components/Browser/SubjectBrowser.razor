@using Namotion.Interceptor.Registry.Abstractions
@using System.Collections

@inherits HomeBlazorComponentBase

@inject NavigationManager NavigationManager
@inject IJSRuntime JsRuntime

@implements IAsyncDisposable

<MudStack Row="true" Class="browser-toolbar mb-2">
    <MudBreadcrumbs Items="_breadcrumbs" />
    <MudSpacer />
</MudStack>

<div id="scrollContainer" style="height: calc(100% - 48px); width: 100%; overflow-x: auto; overflow-y: hidden; display: flex; padding: 0 16px 16px 16px;">
    @for (var i = 0; i < _panes.Count; i++)
    {
        var pane = _panes[i];
        var isFirst = i == 0;
        var selectedChild = i < _panes.Count - 1 ? _panes[i + 1].Subject : null;

        <MudPaper @key="pane.Subject" Width="@((PaneWidth - 16) + "px")"
                  Class="mr-4"
                  Style="@($"min-width: {PaneWidth - 16}px; flex-shrink: 0; height: 100%; display: flex; flex-direction: column;")">
            <SubjectPropertyPanel @key="pane.Subject"
                Subject="@pane.Subject"
                SubjectRegistry="@_subjectRegistry"
                ObjectPath="@pane.ObjectPath"
                SelectedChild="@selectedChild"
                CanClose="@(!isFirst)"
                OnPropertyClick="@((args) => OnPropertyClick(pane, args.PropertyName, args.Index, args.Subject))"
                OnClose="@(() => OnPaneClose(pane))"
                OnDelete="@(() => OnPaneDelete(pane))" />
        </MudPaper>
    }
</div>

@code {
    private const decimal PaneWidth = 400;

    [Parameter]
    public string? Path { get; set; }

    private readonly List<SubjectPane> _panes = [];
    private readonly List<BreadcrumbItem> _breadcrumbs = [];

    private string? _lastNavigatedUrl;
    private bool _scrollToLastPane;

    private IJSObjectReference? _jsModule;
    private ISubjectRegistry? _subjectRegistry;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    protected override void OnParametersSet()
    {
        // Only rebuild if this is the initial load (no panes yet)
        // or if Path changed externally (not from our own navigation)
        if (_panes.Count == 0)
        {
            RebuildFromPath();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./Components/Browser/SubjectBrowser.razor.js");
        }

        if (_scrollToLastPane && _jsModule != null)
        {
            _scrollToLastPane = false;
            var scrollLeft = PaneWidth * (_panes.Count - 1);
            await _jsModule.InvokeVoidAsync("scrollIntoView", "scrollContainer", scrollLeft);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        var uri = new Uri(e.Location);

        // Skip if this is our own programmatic navigation
        if (_lastNavigatedUrl != null && uri.AbsolutePath == _lastNavigatedUrl)
        {
            _lastNavigatedUrl = null;
            return;
        }

        var segments = uri.AbsolutePath.TrimStart('/').Split('/');
        if (segments.Length > 0 && segments[0] == "browser")
        {
            var decodedSegments = segments.Skip(1).Select(Uri.UnescapeDataString);
            Path = string.Join("/", decodedSegments);
           
            RebuildFromPath();
            
            InvokeAsync(StateHasChanged);
        }
    }

    private void RebuildFromPath()
    {
        _panes.Clear();
        _breadcrumbs.Clear();

        if (Root == null) return;

        // Get registry from root's context
        _subjectRegistry = RootContext?.GetService<ISubjectRegistry>();

        // Always show root as first pane
        _panes.Add(new SubjectPane
        {
            Subject = Root,
            DisplayName = "Root",
            ObjectPath = "Root",
            PropertyName = null,
            Index = null
        });

        _breadcrumbs.Add(new BreadcrumbItem("Root", "/browser"));

        if (string.IsNullOrEmpty(Path))
            return;

        var pathSegments = Path.Split('/', StringSplitOptions.RemoveEmptyEntries)
            .Select(Uri.UnescapeDataString)
            .ToArray();

        IInterceptorSubject currentSubject = Root;
        var currentPathParts = new List<string>();
        var currentObjectPath = "Root";
        RegisteredSubjectProperty? pendingProperty = null;

        foreach (var segment in pathSegments)
        {
            if (pendingProperty == null)
            {
                // Expecting a property name
                var registered = _subjectRegistry?.TryGetRegisteredSubject(currentSubject);

                var property = registered?.TryGetProperty(segment);
                if (property is not { HasChildSubjects: true })
                    break;

                currentPathParts.Add(segment);

                // If it's a single subject reference, navigate directly
                if (property.IsSubjectReference)
                {
                    if (property.GetValue() is not IInterceptorSubject child)
                        break;

                    currentObjectPath = $"{currentObjectPath}.{segment}";
                    var breadcrumbPath = "/browser/" + string.Join("/", currentPathParts);
                    _breadcrumbs.Add(new BreadcrumbItem(segment, breadcrumbPath));
                    _panes.Add(new SubjectPane { Subject = child, DisplayName = segment, ObjectPath = currentObjectPath, PropertyName = segment, Index = null });
                    currentSubject = child;
                }
                else
                {
                    // Collection or dictionary - next segment will be the index/key
                    pendingProperty = property;
                }
            }
            else
            {
                // Expecting an index/key for the pending property
                var child = FindChildByIndex(pendingProperty, segment);
                if (child == null)
                    break;

                currentPathParts.Add(segment);
                currentObjectPath = $"{currentObjectPath}.{pendingProperty.Name}[{segment}]";
                var breadcrumbPath = "/browser/" + string.Join("/", currentPathParts);
                var displayName = $"{pendingProperty.Name}[{segment}]";
                _breadcrumbs.Add(new BreadcrumbItem(displayName, breadcrumbPath));
                _panes.Add(new SubjectPane { Subject = child, DisplayName = displayName, ObjectPath = currentObjectPath, PropertyName = pendingProperty.Name, Index = segment });
                currentSubject = child;
                pendingProperty = null;
            }
        }
    }

    private IInterceptorSubject? FindChildByIndex(RegisteredSubjectProperty property, string indexStr)
    {
        // Get the property value directly instead of using cached registry children
        var value = property.GetValue();
        if (value == null)
            return null;

        // Handle Dictionary<string, IInterceptorSubject>
        if (value is IDictionary dictionary)
        {
            foreach (DictionaryEntry entry in dictionary)
            {
                var key = entry.Key?.ToString();
                if (key == indexStr && entry.Value is IInterceptorSubject subject)
                    return subject;
            }
        }
        // Handle List/Array with numeric index
        else if (value is IEnumerable enumerable and not string)
        {
            if (int.TryParse(indexStr, out var index))
            {
                var i = 0;
                foreach (var item in enumerable)
                {
                    if (i == index && item is IInterceptorSubject subject)
                        return subject;
                    i++;
                }
            }
        }

        return null;
    }

    private void OnPropertyClick(SubjectPane clickedPane, string propertyName, object? index, IInterceptorSubject subject)
    {
        // Find the index of the clicked pane
        var paneIndex = _panes.IndexOf(clickedPane);
        if (paneIndex < 0) return;

        // Remove all panes after the clicked one
        while (_panes.Count > paneIndex + 1)
        {
            _panes.RemoveAt(_panes.Count - 1);
        }

        // Build display name and object path
        var displayName = index != null ? $"{propertyName}[{index}]" : propertyName;
        var parentPath = clickedPane.ObjectPath;
        var objectPath = index != null
            ? $"{parentPath}.{propertyName}[{index}]"
            : $"{parentPath}.{propertyName}";

        // Add the new subject pane
        _panes.Add(new SubjectPane
        {
            Subject = subject, 
            DisplayName = displayName, 
            ObjectPath = objectPath,
            PropertyName = propertyName, 
            Index = index
        });

        _scrollToLastPane = true;
        UpdateUrl();
        StateHasChanged();
    }

    private void OnPaneClose(SubjectPane pane)
    {
        var paneIndex = _panes.IndexOf(pane);
        if (paneIndex <= 0) return; // Can't close the root pane

        // Remove this pane and all panes after it
        while (_panes.Count > paneIndex)
        {
            _panes.RemoveAt(_panes.Count - 1);
        }

        UpdateUrl();
        StateHasChanged();
    }

    private async Task OnPaneDelete(SubjectPane pane)
    {
        // TODO: Implement delete functionality
        // This would remove the subject from its parent collection
        await Task.CompletedTask;
    }

    private void UpdateUrl()
    {
        var pathParts = new List<string>();

        // Skip the first pane (root) when building path
        foreach (var pane in _panes.Skip(1))
        {
            // Add property name
            if (pane.PropertyName != null)
            {
                pathParts.Add(Uri.EscapeDataString(pane.PropertyName));
            }

            // Add index/key if present (for collections/dictionaries)
            if (pane.Index != null)
            {
                pathParts.Add(Uri.EscapeDataString(pane.Index.ToString()!));
            }
        }

        var url = "/browser" + (pathParts.Any() ? "/" + string.Join("/", pathParts) : "");

        // Store the URL so OnLocationChanged knows to ignore this navigation
        _lastNavigatedUrl = url;
        NavigationManager.NavigateTo(url, replace: true);

        // Rebuild breadcrumbs
        _breadcrumbs.Clear();
        _breadcrumbs.Add(new BreadcrumbItem("Root", "/browser"));

        var breadcrumbParts = new List<string>();
        foreach (var pane in _panes.Skip(1))
        {
            if (pane.PropertyName != null)
            {
                breadcrumbParts.Add(Uri.EscapeDataString(pane.PropertyName));
            }
            if (pane.Index != null)
            {
                breadcrumbParts.Add(Uri.EscapeDataString(pane.Index.ToString()!));
            }

            var breadcrumbPath = "/browser/" + string.Join("/", breadcrumbParts);
            _breadcrumbs.Add(new BreadcrumbItem(pane.DisplayName, breadcrumbPath));
        }
    }

    public override void Dispose()
    {
        NavigationManager.LocationChanged -= OnLocationChanged;
        base.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        if (_jsModule != null)
        {
            try
            {
                await _jsModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Circuit already disconnected, nothing to clean up
            }
        }
        Dispose();
    }

    private class SubjectPane
    {
        public required IInterceptorSubject Subject { get; init; }

        public string DisplayName { get; init; } = "";
        
        public string ObjectPath { get; init; } = "";
        
        public string? PropertyName { get; init; }
        
        public object? Index { get; init; }
    }
}
