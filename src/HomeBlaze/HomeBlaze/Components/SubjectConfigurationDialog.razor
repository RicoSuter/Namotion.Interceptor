@using System.Reflection
@using HomeBlaze.Abstractions.Attributes
@using Microsoft.AspNetCore.Components.Rendering
@using Namotion.Interceptor

<MudDialog>
    <DialogContent>
        @if (Subject != null && _configProperties.Any())
        {
            <MudForm @ref="_form" @bind-IsValid="@_isValid">
                @foreach (var prop in _configProperties)
                {
                    @RenderPropertyEditor(prop)
                }
            </MudForm>
        }
        else
        {
            <MudText>No configuration properties found.</MudText>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary"
                   OnClick="Save"
                   Disabled="@(!_isValid)">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    private MudForm? _form;
    private bool _isValid;
    private List<ConfigPropertyInfo> _configProperties = new();
    private Dictionary<string, object?> _editValues = new();

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Subject != null)
        {
            _configProperties = GetConfigurationProperties().ToList();
            _editValues = _configProperties.ToDictionary(
                p => p.PropertyInfo.Name,
                p => p.PropertyInfo.GetValue(Subject));
        }
    }

    private IEnumerable<ConfigPropertyInfo> GetConfigurationProperties()
    {
        if (Subject == null) yield break;

        var type = Subject.GetType();
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var configAttr = prop.GetCustomAttribute<ConfigurationAttribute>(true);
            if (configAttr != null && prop.CanRead && prop.CanWrite)
            {
                var stateAttr = prop.GetCustomAttribute<StateAttribute>(true);
                yield return new ConfigPropertyInfo
                {
                    PropertyInfo = prop,
                    DisplayName = stateAttr?.Name ?? SplitCamelCase(prop.Name),
                    Order = stateAttr?.Order ?? int.MaxValue
                };
            }
        }
    }

    private static string SplitCamelCase(string input)
    {
        return System.Text.RegularExpressions.Regex.Replace(
            input, "([a-z])([A-Z])", "$1 $2");
    }

    private RenderFragment RenderPropertyEditor(ConfigPropertyInfo prop) => builder =>
    {
        var propType = prop.PropertyInfo.PropertyType;
        var underlyingType = Nullable.GetUnderlyingType(propType) ?? propType;

        if (underlyingType == typeof(string))
        {
            RenderStringEditor(builder, prop);
        }
        else if (underlyingType == typeof(int))
        {
            RenderIntEditor(builder, prop);
        }
        else if (underlyingType == typeof(double))
        {
            RenderDoubleEditor(builder, prop);
        }
        else if (underlyingType == typeof(decimal))
        {
            RenderDecimalEditor(builder, prop);
        }
        else if (underlyingType == typeof(bool))
        {
            RenderBoolEditor(builder, prop);
        }
        else if (underlyingType == typeof(TimeSpan))
        {
            RenderTimeSpanEditor(builder, prop);
        }
        else if (underlyingType.IsEnum)
        {
            RenderEnumEditor(builder, prop, underlyingType);
        }
        else
        {
            // Fallback to string representation
            RenderStringFallbackEditor(builder, prop);
        }
    };

    private void RenderStringEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var seq = 0;
        builder.OpenComponent<MudTextField<string>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", (string?)_editValues[prop.PropertyInfo.Name]);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, value =>
        {
            _editValues[prop.PropertyInfo.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.PropertyInfo.PropertyType));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderIntEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<int?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", _editValues[prop.PropertyInfo.Name] as int?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<int?>(this, value =>
        {
            _editValues[prop.PropertyInfo.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.PropertyInfo.PropertyType));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderDoubleEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<double?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", _editValues[prop.PropertyInfo.Name] as double?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<double?>(this, value =>
        {
            _editValues[prop.PropertyInfo.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.PropertyInfo.PropertyType));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderDecimalEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var seq = 0;
        builder.OpenComponent<MudNumericField<decimal?>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", _editValues[prop.PropertyInfo.Name] as decimal?);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<decimal?>(this, value =>
        {
            _editValues[prop.PropertyInfo.Name] = value;
        }));
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.PropertyInfo.PropertyType));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderBoolEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var seq = 0;
        builder.OpenComponent<MudCheckBox<bool>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", _editValues[prop.PropertyInfo.Name] is bool b && b);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<bool>(this, value =>
        {
            _editValues[prop.PropertyInfo.Name] = value;
        }));
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderTimeSpanEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var value = _editValues[prop.PropertyInfo.Name];
        var timeSpan = value is TimeSpan ts ? ts : TimeSpan.Zero;
        var totalSeconds = (int)timeSpan.TotalSeconds;

        var seq = 0;
        builder.OpenComponent<MudNumericField<int>>(seq++);
        builder.AddAttribute(seq++, "Label", $"{prop.DisplayName} (seconds)");
        builder.AddAttribute(seq++, "Value", totalSeconds);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<int>(this, seconds =>
        {
            _editValues[prop.PropertyInfo.Name] = TimeSpan.FromSeconds(seconds);
        }));
        builder.AddAttribute(seq++, "Min", 0);
        builder.AddAttribute(seq++, "Required", !IsNullableType(prop.PropertyInfo.PropertyType));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private void RenderEnumEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop, Type enumType)
    {
        // For enums, use a string-based select with conversion
        var enumValues = Enum.GetValues(enumType).Cast<object>().ToList();
        var currentValue = _editValues[prop.PropertyInfo.Name];
        var currentStringValue = currentValue?.ToString() ?? "";

        var seq = 0;
        builder.OpenComponent<MudSelect<string>>(seq++);
        builder.AddAttribute(seq++, "Label", prop.DisplayName);
        builder.AddAttribute(seq++, "Value", currentStringValue);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, value =>
        {
            if (!string.IsNullOrEmpty(value))
            {
                _editValues[prop.PropertyInfo.Name] = Enum.Parse(enumType, value);
            }
        }));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");

        // Add child content with enum values
        builder.AddAttribute(seq++, "ChildContent", (RenderFragment)(childBuilder =>
        {
            foreach (var enumValue in enumValues)
            {
                var strVal = enumValue.ToString() ?? "";
                childBuilder.OpenComponent<MudSelectItem<string>>(0);
                childBuilder.AddAttribute(1, "Value", strVal);
                childBuilder.AddAttribute(2, "ChildContent", (RenderFragment)(textBuilder =>
                {
                    textBuilder.AddContent(0, strVal);
                }));
                childBuilder.CloseComponent();
            }
        }));

        builder.CloseComponent();
    }

    private void RenderStringFallbackEditor(RenderTreeBuilder builder, ConfigPropertyInfo prop)
    {
        var value = _editValues[prop.PropertyInfo.Name];
        var stringValue = value?.ToString() ?? "";

        var seq = 0;
        builder.OpenComponent<MudTextField<string>>(seq++);
        builder.AddAttribute(seq++, "Label", $"{prop.DisplayName} ({prop.PropertyInfo.PropertyType.Name})");
        builder.AddAttribute(seq++, "Value", stringValue);
        builder.AddAttribute(seq++, "ValueChanged", EventCallback.Factory.Create<string>(this, newValue =>
        {
            // Try to convert back - this is best effort
            try
            {
                var converted = Convert.ChangeType(newValue, prop.PropertyInfo.PropertyType);
                _editValues[prop.PropertyInfo.Name] = converted;
            }
            catch
            {
                // Keep as string if conversion fails
                _editValues[prop.PropertyInfo.Name] = newValue;
            }
        }));
        builder.AddAttribute(seq++, "Variant", Variant.Outlined);
        builder.AddAttribute(seq++, "Class", "mb-3");
        builder.CloseComponent();
    }

    private static bool IsNullableType(Type type)
    {
        return Nullable.GetUnderlyingType(type) != null ||
               !type.IsValueType ||
               (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
    }

    private void Cancel() => MudDialog?.Cancel();

    private void Save()
    {
        if (Subject == null) return;

        // Apply all edited values to the subject
        foreach (var prop in _configProperties)
        {
            var newValue = _editValues[prop.PropertyInfo.Name];
            var currentValue = prop.PropertyInfo.GetValue(Subject);

            if (!Equals(newValue, currentValue))
            {
                try
                {
                    // Handle type conversion if needed
                    var targetType = prop.PropertyInfo.PropertyType;
                    var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

                    if (newValue != null && newValue.GetType() != underlyingType)
                    {
                        newValue = Convert.ChangeType(newValue, underlyingType);
                    }

                    prop.PropertyInfo.SetValue(Subject, newValue);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error setting {prop.PropertyInfo.Name}: {ex.Message}");
                }
            }
        }

        MudDialog?.Close(DialogResult.Ok(true));
    }

    private class ConfigPropertyInfo
    {
        public PropertyInfo PropertyInfo { get; set; } = null!;
        public string DisplayName { get; set; } = "";
        public int Order { get; set; }
    }
}
