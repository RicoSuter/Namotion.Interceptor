@using Namotion.Interceptor.Registry.Abstractions

@{
    var underlyingType = Nullable.GetUnderlyingType(Property.Type) ?? Property.Type;
    var isRequired = !IsNullableType(Property.Type);
}

@if (underlyingType == typeof(string))
{
    <MudTextField T="string"
                  Label="@Property.GetDisplayName()"
                  Value="@((string?)Value)"
                  ValueChanged="@(v => OnValueChanged(v))"
                  Required="@isRequired"
                  Variant="Variant.Outlined"
                  Class="mb-3" />
}
else if (underlyingType == typeof(int))
{
    <MudNumericField T="int?"
                     Label="@Property.GetDisplayName()"
                     Value="@(Value as int?)"
                     ValueChanged="@(v => OnValueChanged(v))"
                     Required="@isRequired"
                     Variant="Variant.Outlined"
                     Class="mb-3" />
}
else if (underlyingType == typeof(double))
{
    <MudNumericField T="double?"
                     Label="@Property.GetDisplayName()"
                     Value="@(Value as double?)"
                     ValueChanged="@(v => OnValueChanged(v))"
                     Required="@isRequired"
                     Variant="Variant.Outlined"
                     Class="mb-3" />
}
else if (underlyingType == typeof(decimal))
{
    <MudNumericField T="decimal?"
                     Label="@Property.GetDisplayName()"
                     Value="@(Value as decimal?)"
                     ValueChanged="@(v => OnValueChanged(v))"
                     Required="@isRequired"
                     Variant="Variant.Outlined"
                     Class="mb-3" />
}
else if (underlyingType == typeof(bool))
{
    <MudCheckBox T="bool"
                 Label="@Property.GetDisplayName()"
                 Value="@(Value is bool b && b)"
                 ValueChanged="@(v => OnValueChanged(v))"
                 Class="mb-3" />
}
else if (underlyingType == typeof(TimeSpan))
{
    var timeSpan = Value is TimeSpan ts ? ts : TimeSpan.Zero;
    <MudNumericField T="int"
                     Label="@($"{Property.GetDisplayName()} (seconds)")"
                     Value="@((int)timeSpan.TotalSeconds)"
                     ValueChanged="@((int seconds) => OnValueChanged(TimeSpan.FromSeconds(seconds)))"
                     Min="0"
                     Required="@isRequired"
                     Variant="Variant.Outlined"
                     Class="mb-3" />
}
else if (underlyingType.IsEnum)
{
    <MudSelect T="string"
               Label="@Property.GetDisplayName()"
               Value="@(Value?.ToString() ?? "")"
               ValueChanged="@(v => OnEnumValueChanged(v, underlyingType))"
               Variant="Variant.Outlined"
               Class="mb-3">
        @foreach (var enumValue in Enum.GetValues(underlyingType))
        {
            var strVal = enumValue.ToString() ?? "";
            <MudSelectItem T="string" Value="@strVal">@strVal</MudSelectItem>
        }
    </MudSelect>
}
else
{
    <MudTextField T="string"
                  Label="@($"{Property.GetDisplayName()} ({Property.Type.Name})")"
                  Value="@(Value?.ToString() ?? "")"
                  ValueChanged="@((string v) => OnStringFallbackChanged(v))"
                  Variant="Variant.Outlined"
                  Class="mb-3" />
}

@code {
    [Parameter, EditorRequired]
    public RegisteredSubjectProperty Property { get; set; } = null!;

    [Parameter]
    public object? Value { get; set; }

    [Parameter]
    public EventCallback<object?> ValueChanged { get; set; }

    private async Task OnValueChanged(object? newValue)
    {
        Value = newValue;
        await ValueChanged.InvokeAsync(newValue);
    }

    private async Task OnEnumValueChanged(string value, Type enumType)
    {
        if (!string.IsNullOrEmpty(value))
        {
            await OnValueChanged(Enum.Parse(enumType, value));
        }
    }

    private async Task OnStringFallbackChanged(string newValue)
    {
        try
        {
            var converted = Convert.ChangeType(newValue, Property.Type);
            await OnValueChanged(converted);
        }
        catch
        {
            await OnValueChanged(newValue);
        }
    }

    private static bool IsNullableType(Type type)
    {
        return Nullable.GetUnderlyingType(type) != null ||
               !type.IsValueType ||
               (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
    }
}
