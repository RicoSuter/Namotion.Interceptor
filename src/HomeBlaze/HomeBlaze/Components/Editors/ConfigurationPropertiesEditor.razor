@using Namotion.Interceptor.Registry
@using Namotion.Interceptor.Registry.Abstractions
@using Namotion.Interceptor.Tracking

@implements IDisposable

@if (!_configurationProperties.Any())
{
    <MudText>No configuration properties found.</MudText>
}
else
{
    @if (_externalChangeDetected)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-3">
            Configuration was changed externally. Your unsaved changes may be overwritten.
        </MudAlert>
    }

    <MudForm @bind-IsValid="@_isFormValid">
        @foreach (var prop in _configurationProperties)
        {
            <PropertyEditor Property="@prop"
                            Value="@_editValues[prop.Name]"
                            ValueChanged="@(v => _editValues[prop.Name] = v)" />
        }
    </MudForm>
}

@code {
    private bool _isFormValid;
    private bool _isSaving;
    private bool _externalChangeDetected;

    private List<RegisteredSubjectProperty> _configurationProperties = [];
    private Dictionary<string, object?> _editValues = new();
    private IDisposable? _changeSubscription;

    [Parameter, EditorRequired]
    public IInterceptorSubject? Subject { get; set; }

    public bool IsValid => _isFormValid || !_configurationProperties.Any();
    
    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        _changeSubscription?.Dispose();
        _changeSubscription = null;

        if (Subject != null)
        {
            _configurationProperties = Subject.GetConfigurationProperties()
                .Where(p => p.HasSetter)
                .OrderBy(p => p.GetDisplayOrder())
                .ToList();

            _editValues = _configurationProperties.ToDictionary(
                p => p.Name,
                p => p.GetValue());

            SubscribeToPropertyChanges();
        }
        else
        {
            _configurationProperties = [];
            _editValues = new();
        }
    }

    private void SubscribeToPropertyChanges()
    {
        if (Subject == null) return;

        try
        {
            var observable = Subject.Context.GetPropertyChangeObservable();
            _changeSubscription = observable
                .Subscribe(
                    onNext: change =>
                    {
                        if (change.Property.Subject == Subject &&
                            !_isSaving &&
                            change.Property.TryGetRegisteredProperty()?.IsConfigurationProperty() == true)
                        {
                            _externalChangeDetected = true;
                            InvokeAsync(StateHasChanged);
                        }
                    },
                    onError: _ => { });
        }
        catch
        {
            // PropertyChangeObservable may not be registered
        }
    }

    /// <summary>
    /// Applies all edited values to the subject.
    /// </summary>
    public void ApplyChanges()
    {
        if (Subject == null) return;

        _isSaving = true;
        try
        {
            foreach (var property in _configurationProperties)
            {
                var newValue = _editValues[property.Name];
                var currentValue = property.GetValue();

                if (!Equals(newValue, currentValue))
                {
                    try
                    {
                        var underlyingType = Nullable.GetUnderlyingType(property.Type) ?? property.Type;
                        if (newValue != null && newValue.GetType() != underlyingType)
                        {
                            newValue = Convert.ChangeType(newValue, underlyingType);
                        }

                        property.SetValue(newValue);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error setting {property.Name}: {ex.Message}");
                    }
                }
            }
        }
        finally
        {
            _isSaving = false;
        }
    }

    public void Dispose()
    {
        _changeSubscription?.Dispose();
    }
}
