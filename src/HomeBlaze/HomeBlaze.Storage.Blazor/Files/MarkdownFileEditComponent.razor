@using BlazorMonaco.Editor
@using HomeBlaze.Abstractions.Attributes
@using HomeBlaze.Abstractions.Components
@using HomeBlaze.Storage
@using HomeBlaze.Storage.Files
@using MudBlazor
@using Namotion.Interceptor

@attribute [SubjectComponent(SubjectComponentType.Edit, typeof(MarkdownFile))]
@implements ISubjectEditComponent

@if (_isLoading)
{
    <MudProgressCircular Indeterminate="true" />
}
else
{
    <StandaloneCodeEditor @ref="_editor"
        Id="markdown-editor"
        CssClass="monaco-editor-container"
        ConstructionOptions="GetEditorOptions"
        OnDidChangeModelContent="OnContentChanged" />
}

<style>
    .monaco-editor-container {
        min-height: 500px;
        height: 60vh;
    }
</style>

@code {
    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    private MarkdownFile? File => Subject as MarkdownFile;
    private StandaloneCodeEditor? _editor;
    private string _originalContent = string.Empty;
    private string _currentContent = string.Empty;
    private bool _isLoading = true;

    public bool IsValid => true;
    public bool IsDirty => _currentContent != _originalContent;

    public event Action<bool>? IsValidChanged
    {
        add { }
        remove { }
    }
    public event Action<bool>? IsDirtyChanged;

    private StandaloneEditorConstructionOptions GetEditorOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "markdown",
            Value = _originalContent,
            WordWrap = "on",
            Theme = "vs-dark"
        };
    }

    protected override async Task OnParametersSetAsync()
    {
        if (File != null && _isLoading)
        {
            await using var stream = await File.ReadAsync(CancellationToken.None);
            using var reader = new StreamReader(stream);
            _originalContent = await reader.ReadToEndAsync();
            _currentContent = _originalContent;
            _isLoading = false;
        }
    }

    private void OnContentChanged(ModelContentChangedEvent e)
    {
        // Content changed, we'll get the actual value on save
        // For now, mark as potentially dirty
        Task.Run(async () =>
        {
            if (_editor != null)
            {
                _currentContent = await _editor.GetValue();
                await InvokeAsync(() =>
                {
                    IsDirtyChanged?.Invoke(IsDirty);
                    StateHasChanged();
                });
            }
        });
    }

    public async Task SaveAsync(CancellationToken cancellationToken)
    {
        if (File == null || _editor == null) return;

        var content = await _editor.GetValue();
        
        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(content));
        await File.WriteAsync(stream, cancellationToken);

        _originalContent = content;
        _currentContent = content;
        
        IsDirtyChanged?.Invoke(false);
    }
}
