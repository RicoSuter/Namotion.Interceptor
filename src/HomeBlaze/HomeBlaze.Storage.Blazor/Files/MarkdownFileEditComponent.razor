@using System.Text.RegularExpressions
@using BlazorMonaco.Editor
@using HomeBlaze.Abstractions
@using HomeBlaze.Components.Abstractions
@using HomeBlaze.Components.Abstractions.Attributes
@using HomeBlaze.Services
@using HomeBlaze.Storage.Blazor.Models
@using HomeBlaze.Storage.Files
@using HomeBlaze.Storage.Internal
@using Microsoft.AspNetCore.Components.Sections
@using Microsoft.JSInterop
@using MudBlazor
@using Namotion.Interceptor

@inject IJSRuntime JsRuntime
@inject IDialogService DialogService
@inject ConfigurableSubjectSerializer Serializer

@attribute [SubjectComponent(SubjectComponentType.Edit, typeof(MarkdownFile))]
@implements ISubjectEditComponent

@if (_isLoading)
{
    <MudProgressCircular Indeterminate="true"/>
}
else
{
    <SectionContent SectionName="EditActions">
        @if (_activeRegion != null)
        {
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Edit"
                       OnClick="OnEditButtonClick"
                       data-testid="@(_activeRegion.Type == DecorationRegionType.SubjectBlock ? "edit-subject-button" : "edit-expression-button")">
                @(_activeRegion.Type == DecorationRegionType.SubjectBlock ? $"Edit {_activeRegion.Name}" : "Edit Expression")
            </MudButton>
        }
    </SectionContent>

    <StandaloneCodeEditor @ref="_editor"
                          Id="markdown-editor"
                          CssClass="monaco-editor-container"
                          ConstructionOptions="GetEditorOptions"
                          OnDidInit="OnEditorInit"
                          OnDidChangeModelContent="OnContentChanged"
                          OnDidChangeCursorPosition="OnCursorPositionChanged"/>
}

<style>
    .monaco-editor-container {
        height: calc(100vh - 200px);
        width: 100%;
    }

    /* Decoration styles for subject blocks and expressions */
    .subject-block-decoration {
        background-color: rgba(65, 105, 225, 0.25); /* Royal blue, works in light/dark modes */
        border-radius: 3px;
    }

    .expression-decoration {
        background-color: rgba(65, 105, 225, 0.25); /* Royal blue, works in light/dark modes */
        border-radius: 3px;
    }
</style>

@code {
    [Parameter] public IInterceptorSubject? Subject { get; set; }

    [CascadingParameter(Name = "IsDarkMode")]
    public bool IsDarkMode { get; set; } = true;

    private MarkdownFile? File => Subject as MarkdownFile;
    private StandaloneCodeEditor? _editor;
    private string _originalContent = string.Empty;
    private string _currentContent = string.Empty;
    private bool _isLoading = true;
    private bool _previousDarkMode = true;
    private List<DecorationRegion> _decorationRegions = new();
    private string[] _currentDecorationIds = Array.Empty<string>();
    private DecorationRegion? _activeRegion;

    private string MonacoTheme => IsDarkMode ? "vs-dark" : "vs";

    public bool IsValid => true;
    public bool IsDirty => _currentContent != _originalContent;

    public event Action<bool>? IsValidChanged
    {
        add { }
        remove { }
    }

    public event Action<bool>? IsDirtyChanged;

    private StandaloneEditorConstructionOptions GetEditorOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "markdown",
            Value = _originalContent,
            WordWrap = "on",
            Theme = MonacoTheme
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        // Update Monaco theme when dark mode changes
        if (_editor != null && _previousDarkMode != IsDarkMode)
        {
            _previousDarkMode = IsDarkMode;
            await Global.SetTheme(JsRuntime, MonacoTheme);
        }
    }

    private async Task OnEditorInit()
    {
        // Apply initial decorations
        await RefreshDecorationsAsync();
    }

    private void OnCursorPositionChanged(CursorPositionChangedEvent e)
    {
        // Find if cursor is inside any decoration region
        var cursorLine = e.Position.LineNumber;
        var cursorColumn = e.Position.Column;

        var previousRegion = _activeRegion;
        _activeRegion = _decorationRegions.FirstOrDefault(r => r.ContainsPosition(cursorLine, cursorColumn));

        // Only update UI if active region changed
        if (_activeRegion != previousRegion)
        {
            StateHasChanged();
        }
    }

    private async Task OnEditButtonClick()
    {
        if (_activeRegion == null)
            return;

        if (_activeRegion.Type == DecorationRegionType.SubjectBlock)
        {
            await OnEditSubjectClick(_activeRegion);
        }
        else
        {
            await OnEditExpressionClick(_activeRegion);
        }
    }

    private async Task OnEditSubjectClick(DecorationRegion region)
    {
        if (File == null || _editor == null)
            return;

        // Get the subject from File.Children
        if (!File.Children.TryGetValue(region.Name, out var subject))
            return;

        // Open the SubjectEditDialog
        // Note: SubjectEditDialog is in HomeBlaze.Host, so we use a dynamic type name
        var parameters = new DialogParameters<object>
        {
            { "Subject", subject }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        // Use dynamic type lookup for SubjectEditDialog since it's in HomeBlaze.Host
        var dialogType = Type.GetType("HomeBlaze.Host.Components.Dialogs.SubjectEditDialog, HomeBlaze.Host");
        if (dialogType == null)
            return;

        var dialog = await DialogService.ShowAsync(dialogType, $"Edit {region.Name}", parameters, options);
        var result = await dialog.Result;

        if (result?.Canceled != false)
            return;

        // Serialize the updated subject back to JSON
        var newJson = Serializer.Serialize(subject);

        // Replace the subject block in the content
        var pattern = $@"```subject\({Regex.Escape(region.Name)}\)\s*\n[\s\S]*?```";
        var replacement = $"```subject({region.Name})\n{newJson}\n```";
        _currentContent = Regex.Replace(_currentContent, pattern, replacement);

        // Update the Monaco editor
        await _editor.SetValue(_currentContent);

        // Refresh decorations
        await RefreshDecorationsAsync();

        // Save the file
        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(_currentContent));
        await File.WriteAsync(stream, CancellationToken.None);

        // Apply configuration if needed
        if (subject is IConfigurableSubject configurable)
        {
            await configurable.ApplyConfigurationAsync(CancellationToken.None);
        }

        // Update dirty state
        _originalContent = _currentContent;
        IsDirtyChanged?.Invoke(false);
    }

    private async Task OnEditExpressionClick(DecorationRegion region)
    {
        if (File == null || _editor == null)
            return;

        // Filter to only include actual subject blocks (not HtmlSegment, RenderExpression, etc.)
        var subjectBlocks = File.Children
            .Where(kvp => kvp.Value is not HtmlSegment && kvp.Value is not RenderExpression)
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        // Open the ExpressionEditDialog
        var parameters = new DialogParameters<object>
        {
            { "SelectedPath", region.Name },
            { "LocalSubjects", subjectBlocks }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        // Use dynamic type lookup for ExpressionEditDialog since it's in HomeBlaze.Host
        var dialogType = Type.GetType("HomeBlaze.Host.Components.Dialogs.ExpressionEditDialog, HomeBlaze.Host");
        if (dialogType == null)
            return;

        var dialog = await DialogService.ShowAsync(dialogType, "Edit Expression", parameters, options);
        var result = await dialog.Result;

        if (result?.Canceled != false || result.Data is not string newPath)
            return;

        // Replace the expression in the content
        // Find the exact expression using the decoration region position
        var lines = _currentContent.Split('\n');
        var startLineIndex = region.StartLine - 1;
        var endLineIndex = region.EndLine - 1;

        if (startLineIndex == endLineIndex)
        {
            // Single line expression
            var line = lines[startLineIndex];
            var before = line[..(region.StartColumn - 1)];
            var after = line[(region.EndColumn - 1)..];
            lines[startLineIndex] = $"{before}{{{{ {newPath} }}}}{after}";
        }
        else
        {
            // Multi-line expression (unlikely but handle it)
            var firstLine = lines[startLineIndex][..(region.StartColumn - 1)];
            var lastLine = lines[endLineIndex][(region.EndColumn - 1)..];
            lines[startLineIndex] = $"{firstLine}{{{{ {newPath} }}}}{lastLine}";
            // Remove intermediate lines
            for (int i = endLineIndex; i > startLineIndex; i--)
            {
                lines = lines.Take(i).Concat(lines.Skip(i + 1)).ToArray();
            }
        }

        _currentContent = string.Join('\n', lines);

        // Update the Monaco editor
        await _editor.SetValue(_currentContent);

        // Refresh decorations
        await RefreshDecorationsAsync();

        // Save the file
        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(_currentContent));
        await File.WriteAsync(stream, CancellationToken.None);

        // Update dirty state
        _originalContent = _currentContent;
        IsDirtyChanged?.Invoke(false);
    }

    private async Task RefreshDecorationsAsync()
    {
        if (_editor == null)
            return;

        // Parse decoration regions from current content
        _decorationRegions = MarkdownDecorationParser.Parse(_currentContent, File?.Children);

        // Convert to Monaco decorations
        var decorations = _decorationRegions.Select(region => new ModelDeltaDecoration
        {
            Range = new BlazorMonaco.Range(
                region.StartLine,
                region.StartColumn,
                region.EndLine,
                region.EndColumn),
            Options = new ModelDecorationOptions
            {
                ClassName = region.Type == DecorationRegionType.SubjectBlock
                    ? "subject-block-decoration"
                    : "expression-decoration",
                IsWholeLine = false
            }
        }).ToArray();

        // Apply decorations (delta update - removes old, adds new)
        _currentDecorationIds = await _editor.DeltaDecorations(_currentDecorationIds, decorations);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (File != null && _isLoading)
        {
            await using var stream = await File.ReadAsync(CancellationToken.None);
            using var reader = new StreamReader(stream);
            _originalContent = await reader.ReadToEndAsync();
            _currentContent = _originalContent;
            _isLoading = false;
        }
    }

    private void OnContentChanged(ModelContentChangedEvent e)
    {
        // Content changed, we'll get the actual value on save
        // For now, mark as potentially dirty
        Task.Run(async () =>
        {
            if (_editor != null)
            {
                _currentContent = await _editor.GetValue();

                // Refresh decorations after content change
                await RefreshDecorationsAsync();

                await InvokeAsync(() =>
                {
                    IsDirtyChanged?.Invoke(IsDirty);
                    StateHasChanged();
                });
            }
        });
    }

    public async Task SaveAsync(CancellationToken cancellationToken)
    {
        if (File == null || _editor == null) return;

        var content = await _editor.GetValue();

        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(content));
        await File.WriteAsync(stream, cancellationToken);

        _originalContent = content;
        _currentContent = content;

        IsDirtyChanged?.Invoke(false);
    }

}
