@using System.Text
@using System.Web
@using HomeBlaze.Components
@using HomeBlaze.Components.Abstractions
@using HomeBlaze.Components.Abstractions.Attributes
@using HomeBlaze.Storage.Files
@using HomeBlaze.Storage.Internal
@using MudBlazor
@using Namotion.Interceptor

@attribute [SubjectComponent(SubjectComponentType.Page, typeof(MarkdownFile))]

@implements ISubjectComponent

<CascadingValue Value="@IsEditing" Name="IsEditing">
    <div class="markdown-content" style="position: relative;">
        @if (IsLoading)
        {
            <MudProgressCircular Indeterminate="true" />
        }
        else
        {
            <div class="markdown-page-toolbar" style="position: absolute; top: 0.5rem; right: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                <span style="font-size: 0.8rem; color: rgba(128,128,128,0.7);">
                    @File?.LastModified.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss")
                </span>
            </div>
            @foreach (var segment in GetRenderSegments())
            {
                @if (segment.Html != null)
                {
                    @((MarkupString)segment.Html)
                }
                else if (segment.Widget != null)
                {
                    <SubjectComponent Subject="@segment.Widget" Type="SubjectComponentType.Widget" />
                }
            }
        }
    </div>
</CascadingValue>

<style>
    .markdown-content h1 { font-size: 2rem; font-weight: 500; margin: 1.5rem 0 1rem; }
    .markdown-content h2 { font-size: 1.5rem; font-weight: 500; margin: 1.25rem 0 0.75rem; }
    .markdown-content h3 { font-size: 1.25rem; font-weight: 500; margin: 1rem 0 0.5rem; }
    .markdown-content p { margin: 0.75rem 0; line-height: 1.6; }
    .markdown-content ul, .markdown-content ol { margin: 0.75rem 0; padding-left: 1.5rem; }
    .markdown-content li { margin: 0.25rem 0; }
    .markdown-content code { background: rgba(0,0,0,0.1); padding: 0.2em 0.4em; border-radius: 4px; font-family: monospace; }
    .markdown-content pre { background: rgba(0,0,0,0.1); padding: 1rem; border-radius: 8px; overflow-x: auto; margin: 1rem 0; }
    .markdown-content pre code { background: transparent; padding: 0; }
    .markdown-content table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
    .markdown-content th, .markdown-content td { border: 1px solid rgba(128,128,128,0.3); padding: 0.5rem; text-align: left; }
    .markdown-content th { background: rgba(0,0,0,0.05); font-weight: 500; }
    .markdown-content blockquote { border-left: 4px solid rgba(128,128,128,0.3); margin: 1rem 0; padding-left: 1rem; color: rgba(128,128,128,0.8); }
    .markdown-content a { color: #7e6fff; text-decoration: none; }
    .markdown-content a:hover { text-decoration: underline; }
</style>

@code {
    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    [CascadingParameter(Name = "IsEditing")]
    public bool IsEditing { get; set; }

    private MarkdownFile? File => Subject as MarkdownFile;

    private bool IsLoading => File?.Content is null;

    private record RenderSegment(string? Html, IInterceptorSubject? Widget);

    private List<RenderSegment> GetRenderSegments()
    {
        var result = new List<RenderSegment>();
        if (File?.Children is null)
            return result;

        StringBuilder? sb = null;

        foreach (var child in File.Children.Values)
        {
            if (child is HtmlSegment html)
            {
                sb ??= new StringBuilder();
                sb.Append(html.Html);
            }
            else if (child is RenderExpression expr)
            {
                sb ??= new StringBuilder();
                sb.Append(HttpUtility.HtmlEncode(expr.Value?.ToString() ?? string.Empty));
            }
            else
            {
                // Flush accumulated HTML before widget
                if (sb is { Length: > 0 })
                {
                    result.Add(new RenderSegment(sb.ToString(), null));
                    sb.Clear();
                }
                result.Add(new RenderSegment(null, child));
            }
        }

        // Flush remaining HTML
        if (sb is { Length: > 0 })
        {
            result.Add(new RenderSegment(sb.ToString(), null));
        }

        return result;
    }
}
