@using BlazorMonaco.Editor
@using HomeBlaze.Components.Abstractions
@using HomeBlaze.Components.Abstractions.Attributes
@using HomeBlaze.Storage
@using HomeBlaze.Storage.Files
@using Namotion.Interceptor

@attribute [SubjectComponent(SubjectComponentType.Edit, typeof(JsonFile))]
@implements ISubjectEditComponent

<StandaloneCodeEditor @ref="_editor"
    Id="json-editor"
    CssClass="monaco-editor-container"
    ConstructionOptions="GetEditorOptions"
    OnDidChangeModelContent="OnContentChanged" />

<style>
    .monaco-editor-container {
        min-height: 500px;
        height: 60vh;
    }
</style>

@code {
    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    [Parameter]
    public bool IsCreating { get; set; }

    private JsonFile? File => Subject as JsonFile;
    private StandaloneCodeEditor? _editor;
    private string _originalContent = string.Empty;
    private string _currentContent = string.Empty;

    public bool IsValid => true;
    public bool IsDirty => _currentContent != _originalContent;

#pragma warning disable CS0067 // Event is never used - required by ISubjectEditComponent
    public event Action<bool>? IsValidChanged;
#pragma warning restore CS0067
    public event Action<bool>? IsDirtyChanged;

    private StandaloneEditorConstructionOptions GetEditorOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "json",
            Value = _originalContent,
            Theme = "vs-dark"
        };
    }

    protected override async Task OnInitializedAsync()
    {
        if (File != null)
        {
            await using var stream = await File.ReadAsync(CancellationToken.None);
            using var reader = new StreamReader(stream);
            _originalContent = await reader.ReadToEndAsync();
            _currentContent = _originalContent;
        }
    }

    private void OnContentChanged(ModelContentChangedEvent e)
    {
        Task.Run(async () =>
        {
            if (_editor != null)
            {
                _currentContent = await _editor.GetValue();
                await InvokeAsync(() =>
                {
                    IsDirtyChanged?.Invoke(IsDirty);
                    StateHasChanged();
                });
            }
        });
    }

    public async Task SaveAsync(CancellationToken cancellationToken)
    {
        if (File == null || _editor == null) return;

        var content = await _editor.GetValue();

        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(content));
        await File.WriteAsync(stream, CancellationToken.None);
        _originalContent = content;
        _currentContent = content;
        IsDirtyChanged?.Invoke(false);
    }
}
