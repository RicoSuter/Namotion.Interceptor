@using HomeBlaze.Abstractions
@using HomeBlaze.Services
@using HomeBlaze.Storage.Abstractions
@using Namotion.Interceptor.Tracking.Parent

@implements IAsyncDisposable

@inject RootManager RootManager
@inject SubjectComponentRegistry ComponentRegistry
@inject ISnackbar Snackbar
@inject DeveloperModeService DeveloperMode

<TrackingScope Context="Subject?.Context" ShowDebugInfo="DeveloperMode.IsEnabled">
    @if (Subject != null)
    {
        @if (ComponentRegistry.HasComponent(Subject.GetType(), SubjectComponentType.Edit))
        {
            <SubjectComponent Subject="@Subject"
                              Type="SubjectComponentType.Edit"
                              AdditionalParameters="@(new Dictionary<string, object?> { ["IsCreating"] = IsCreating })"
                              @bind-ComponentInstance="_subjectComponent" />
        }
        else
        {
            <ConfigurationPropertiesEditor @ref="_propertiesEditor" Subject="@Subject" />
        }
    }
</TrackingScope>

@code {
    [Parameter] public IInterceptorSubject? Subject { get; set; }

    [Parameter] public bool IsCreating { get; set; }

    private ISubjectComponent? _subjectComponent;
    private ISubjectEditComponent? _editComponent;
    private ConfigurationPropertiesEditor? _propertiesEditor;

    public bool IsValid => _editComponent?.IsValid ?? _propertiesEditor?.IsValid ?? true;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // TODO: Extract event subscription/unsubscription to helper method - logic duplicated in OnParametersSet, OnAfterRender, and DisposeAsync
        // Unsubscribe from previous edit component
        if (_editComponent != null)
        {
            _editComponent.IsValidChanged -= OnIsValidChanged;
            _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
            _editComponent = null;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        // Subscribe to new edit component if available
        if (_subjectComponent is ISubjectEditComponent editComponent && _editComponent != editComponent)
        {
            if (_editComponent != null)
            {
                _editComponent.IsValidChanged -= OnIsValidChanged;
                _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
            }

            _editComponent = editComponent;
            _editComponent.IsValidChanged += OnIsValidChanged;
            _editComponent.IsDirtyChanged += OnIsDirtyChanged;
            StateHasChanged();
        }
    }

    private void OnIsValidChanged(bool isValid) => InvokeAsync(StateHasChanged);

    private void OnIsDirtyChanged(bool isDirty) => InvokeAsync(StateHasChanged);

    public async Task SaveAsync(CancellationToken cancellationToken)
    {
        var subject = Subject;
        if (subject == null) return;

        try
        {
            if (_editComponent != null)
            {
                if (!_editComponent.IsValid)
                {
                    return;
                }

                await _editComponent.SaveAsync(cancellationToken);
            }
            else
            {
                if (_propertiesEditor?.HasErrors == true)
                {
                    return;
                }

                _propertiesEditor?.ApplyChanges();
            }

            if (subject is not IConfigurableSubject)
            {
                subject = subject.TryGetFirstParent<IConfigurableSubject>() as IInterceptorSubject;
            }

            if (subject is IConfigurableSubject)
            {
                var configurationWriter = subject.TryGetFirstParent<IConfigurationWriter>() ?? RootManager;
                await configurationWriter.WriteConfigurationAsync(subject, CancellationToken.None);
            }

            if (subject is IStorageFile storageFile)
            {
                await storageFile.OnFileChangedAsync(cancellationToken);
            }

            if (subject is IConfigurableSubject configurableSubject)
            {
                await configurableSubject.ApplyConfigurationAsync(cancellationToken);
            }

            Snackbar.Add("Configuration saved.", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving configuration: {ex.Message}", Severity.Error);
        }
    }

    public ValueTask DisposeAsync()
    {
        if (_editComponent != null)
        {
            _editComponent.IsValidChanged -= OnIsValidChanged;
            _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
        }

        return ValueTask.CompletedTask;
    }

    private T FindNearest<T>(IInterceptorSubject subject)
    {
        // TODO: Replace with BFS when available in Namotion.Interceptor.Tracking

        // Check if the subject itself is a writer
        if (subject is T writer)
        {
            return writer;
        }

        // Traverse parents to find the nearest IConfigurationWriter
        var visited = new HashSet<IInterceptorSubject>();
        var current = subject;

        while (current != null)
        {
            if (!visited.Add(current))
            {
                break; // Avoid infinite loops
            }

            var parents = current.GetParents();
            if (parents.Length == 0)
            {
                break;
            }

            // Get the first parent's subject
            var parentSubject = parents[0].Property.Subject;
            if (parentSubject is T parentWriter)
            {
                return parentWriter;
            }

            current = parentSubject;
        }

        return default!;
    }
}
