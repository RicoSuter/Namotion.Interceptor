@using HomeBlaze.Abstractions
@using HomeBlaze.Abstractions.Services
@using HomeBlaze.Authorization.Blazor.Components
@using HomeBlaze.Host.Components.Dialogs
@using HomeBlaze.Services
@using HomeBlaze.Storage.Abstractions

@inject IDialogService DialogService
@inject SubjectComponentRegistry ComponentRegistry
@inject DeveloperModeService DeveloperMode
@inject ISubjectMethodInvoker MethodInvoker
@inject IServiceProvider ServiceProvider
@inject AuthenticationStateProvider AuthStateProvider
@inject IAuthorizationResolver AuthorizationResolver
@inject IRoleExpander RoleExpander

<TrackingScope Context="Subject?.Context" ShowDebugInfo="DeveloperMode.IsEnabled">
@if (Subject != null)
{
    @* Header - Fixed at top *@
    <MudListSubheader Style="flex-shrink: 0;">
        @if (CanClose)
        {
            <MudFab OnClick="@(() => OnClose.InvokeAsync())"
                    Color="Color.Primary"
                    StartIcon="@Icons.Material.Filled.Close"
                    Size="Size.Small"
                    Style="float: right" />
        }

        <h1 style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 0;">
            <MudIcon Size="Size.Small" Icon="@GetSubjectIcon(Subject)" Color="@GetSubjectIconColor(Subject)" Class="mr-2" Style="vertical-align: middle;" />
            @GetSubjectTitle()
        </h1>
    </MudListSubheader>
    <MudListSubheader Style="word-break: break-word;">
        @* Action Buttons *@
        @if (CanEdit())
        {
            <MudIconButton OnClick="@OpenEditDialog"
                           Icon="@Icons.Material.Filled.Edit"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           Size="Size.Small"
                           Class="mr-2" />
        }
        @if (Subject is IStorageFile or IConfigurableSubject)
        {
            <MudIconButton OnClick="@(() => OnDelete.InvokeAsync())"
                           Icon="@Icons.Material.Filled.Delete"
                           Variant="Variant.Filled"
                           Color="Color.Error"
                           Size="Size.Small"
                           Class="mr-2" />
        }
        <AuthorizeView Roles="Admin">
            <Authorized>
                <MudTooltip Text="Authorization">
                    <MudIconButton OnClick="@OpenAuthorizationDialog"
                                   Icon="@Icons.Material.Filled.Lock"
                                   Variant="Variant.Outlined"
                                   Color="Color.Warning"
                                   Size="Size.Small"
                                   Class="mr-2" />
                </MudTooltip>
            </Authorized>
        </AuthorizeView>
    </MudListSubheader>

    <div style="max-height: calc(100vh - 300px); overflow-y: auto; overflow-x: hidden;">
        <MudListSubheader Style="word-break: break-word;">
            @* Primitive Properties *@
            @foreach (var prop in GetPrimitiveProperties())
            {
                @RenderProperty(prop, 0)
            }
        </MudListSubheader>

        @* Methods Section (Operations & Queries) *@
        @{
            var methods = GetMethods();
            if (methods.Count > 0)
            {
                <MudStack Class="pl-4 pr-4">
                    @foreach (var method in methods)
                    {
                        var isQuery = method.Kind == SubjectMethodKind.Query;
                        var defaultIcon = isQuery ? "Search" : "PlayArrow";
                        var methodName = method.MethodInfo.Name.Replace("Async", string.Empty, StringComparison.OrdinalIgnoreCase);
                        var methodProperty = _registeredSubject?.TryGetProperty(methodName);
                        var isEnabledAttribute = methodProperty?.TryGetAttribute(KnownAttributes.IsEnabled);
                        var isEnabled = isEnabledAttribute?.GetValue() as bool? ?? true;
                        var hasMethodOverride = HasMethodAuthorizationOverride(method);
                        <div class="d-flex align-center gap-1">
                            <MudButton Variant="Variant.Filled"
                                       Color="@(isQuery ? Color.Info : Color.Primary)"
                                       Size="Size.Small"
                                       FullWidth="true"
                                       StartIcon="@SubjectIconExtensions.ResolveMudBlazorIcon(method.Icon ?? defaultIcon)"
                                       Disabled="@(_executingOperation == method || !isEnabled)"
                                       OnClick="@(() => ExecuteMethodAsync(method))">
                                @if (_executingOperation == method)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                }
                                @method.Title
                            </MudButton>
                            <AuthorizeView Roles="Admin">
                                <Authorized>
                                    <MudTooltip Text="@(hasMethodOverride ? "Authorization (Override)" : "Authorization")">
                                        <MudIconButton Icon="@(hasMethodOverride ? Icons.Material.Filled.Lock : Icons.Material.Outlined.Lock)"
                                                       Size="Size.Small"
                                                       Color="@(hasMethodOverride ? Color.Warning : Color.Default)"
                                                       OnClick="@(() => OpenMethodAuthorizationDialog(method))" />
                                    </MudTooltip>
                                </Authorized>
                            </AuthorizeView>
                        </div>
                    }
                </MudStack>
            }
        }

        @* Child Collections *@
        @foreach (var property in GetChildProperties())
        {
            var children = GetFilteredChildren(property);
            @if (children.Length == 1)
            {
                @* Single child - no expansion panel *@
                <MudList T="object" SelectedValue="SelectedChild" Color="Color.Primary" Style="padding-top: 0; padding-bottom: 0">
                    @{
                        var child = children[0];
                        var isSelected = child.Subject == SelectedChild;
                        var childCount = GetChildCount(child);
                    }
                    <MudListItem Value="@child.Subject"
                                 OnClick="@(() => OnPropertyClick.InvokeAsync(new PropertyClickEventArgs(property.Name, child.Index, child.Subject)))"
                                 Icon="@GetSubjectIcon(child.Subject)"
                                 IconColor="@(isSelected ? Color.Primary : GetSubjectIconColor(child.Subject))"
                                 Class="@(isSelected ? "mud-primary-text" : "")">
                        @if (isSelected)
                        {
                            <div style="float: right; line-height: 0">
                                <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Color="Color.Primary" />
                            </div>
                        }
                        <span style="word-break: break-word;">@GetSubjectDisplayName(child)</span>
                        @if (childCount > 0)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Dark">@childCount</MudChip>
                        }
                    </MudListItem>
                    <MudDivider />
                </MudList>
            }
            else if (children.Length > 1)
            {
                <MudExpansionPanel Gutters="false" Dense="true" Expanded="true" Class="px-4">
                    <TitleContent>
                        @GetPropertyDisplayName(property)
                        <MudChip T="string" Size="Size.Small" Color="Color.Dark">@children.Length</MudChip>
                    </TitleContent>
                    <ChildContent>
                        <MudList T="object" SelectedValue="SelectedChild" Color="Color.Primary">
                            @foreach (var child in children)
                            {
                                var isSelected = child.Subject == SelectedChild;
                                var childCount = GetChildCount(child);
                                
                                <MudListItem Value="@child.Subject"
                                             OnClick="@(() => OnPropertyClick.InvokeAsync(new PropertyClickEventArgs(property.Name, child.Index, child.Subject)))"
                                             Icon="@GetSubjectIcon(child.Subject)"
                                             IconColor="@(isSelected ? Color.Primary : GetSubjectIconColor(child.Subject))"
                                             Class="@(isSelected ? "mud-primary-text" : "")">
                                    @if (isSelected)
                                    {
                                        <div style="float: right; line-height: 0">
                                            <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Color="Color.Primary" />
                                        </div>
                                    }
                                    <span style="word-break: break-word;">@GetSubjectDisplayName(child)</span>
                                    @if (childCount > 0)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Dark">@childCount</MudChip>
                                    }
                                </MudListItem>
                                <MudDivider />
                            }
                        </MudList>
                    </ChildContent>
                </MudExpansionPanel>
            }
        }

        @* Details Accordion *@
        <MudExpansionPanels MultiExpansion="true" Elevation="0" Gutters="false" Dense="true" Style="overflow: hidden;">
            <MudExpansionPanel Expanded="false" Gutters="false" Class="px-4">
                <TitleContent>
                    Details
                </TitleContent>
                <ChildContent>
                    <div class="mb-4">
                        <small style="word-break: break-all;">
                            <p class="my-1"><strong>ID:</strong> @GetObjectPath()</p>
                            <p class="my-1"><strong>Type:</strong> @Subject.GetType().FullName</p>
                        </small>
                    </div>
                </ChildContent>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </div>
}
</TrackingScope>

@code {
    private readonly HashSet<string> _expandedProperties = [];

    private RegisteredSubject? _registeredSubject;
    private SubjectMethodInfo? _executingOperation;
    private IReadOnlySet<string>? _userExpandedRoles;

    [Parameter]
    public IInterceptorSubject? Subject { get; set; }

    [Parameter]
    public ISubjectRegistry? SubjectRegistry { get; set; }

    [Parameter]
    public IInterceptorSubject? SelectedChild { get; set; }

    [Parameter]
    public bool CanClose { get; set; }

    [Parameter]
    public string? ObjectPath { get; set; }

    [Parameter]
    public EventCallback<PropertyClickEventArgs> OnPropertyClick { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback OnDelete { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadUserRolesAsync();
    }

    private async Task LoadUserRolesAsync()
    {
        try
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user.Identity?.IsAuthenticated == true)
            {
                var userRoles = user.Claims
                    .Where(c => c.Type == System.Security.Claims.ClaimTypes.Role)
                    .Select(c => c.Value)
                    .ToList();
                _userExpandedRoles = RoleExpander.ExpandRoles(userRoles);
            }
            else
            {
                // Anonymous user gets Anonymous role
                _userExpandedRoles = RoleExpander.ExpandRoles(["Anonymous"]);
            }
        }
        catch
        {
            // Fallback to anonymous if auth state can't be determined
            _userExpandedRoles = RoleExpander.ExpandRoles(["Anonymous"]);
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _registeredSubject = Subject != null && SubjectRegistry != null
            ? SubjectRegistry.TryGetRegisteredSubject(Subject)
            : null;
    }

    private string GetSubjectTitle()
    {
        return Subject switch
        {
            null => "No Selection",
            ITitleProvider titleProvider when !string.IsNullOrEmpty(titleProvider.Title) => titleProvider.Title,
            _ => Subject.GetType().Name
        };
    }

    private string GetSubjectIcon(IInterceptorSubject? subject)
    {
        if (subject == null)
            return Icons.Material.Filled.QuestionMark;

        return SubjectIconExtensions.ResolveMudBlazorIcon(subject.GetIcon());
    }

    private Color GetSubjectIconColor(IInterceptorSubject? subject)
    {
        if (subject == null)
            return Color.Default;

        return SubjectIconExtensions.ResolveMudBlazorColor(subject.GetIconColor());
    }

    private string GetObjectPath()
    {
        return ObjectPath ?? "Root";
    }

    private IEnumerable<RegisteredSubjectProperty> GetPrimitiveProperties()
    {
        if (_registeredSubject == null)
            return [];

        return _registeredSubject.Properties
            .Where(p => p.GetStateAttribute() != null && !HasChildSubjects(p) && CanReadProperty(p))
            .OrderBy(p => p.GetDisplayPosition());
    }

    private bool CanReadProperty(RegisteredSubjectProperty property)
    {
        if (Subject == null || _userExpandedRoles == null)
            return true;

        var entity = property.IsConfigurationProperty()
            ? AuthorizationEntity.Configuration
            : AuthorizationEntity.State;

        var requiredRoles = AuthorizationResolver.ResolvePropertyRoles(
            new PropertyReference(Subject, property.Name),
            entity,
            AuthorizationAction.Read);

        return requiredRoles.Any(r => _userExpandedRoles.Contains(r));
    }

    private bool CanWriteProperty(RegisteredSubjectProperty property)
    {
        if (Subject == null || _userExpandedRoles == null)
            return true;

        var entity = property.IsConfigurationProperty()
            ? AuthorizationEntity.Configuration
            : AuthorizationEntity.State;

        var requiredRoles = AuthorizationResolver.ResolvePropertyRoles(
            new PropertyReference(Subject, property.Name),
            entity,
            AuthorizationAction.Write);

        return requiredRoles.Any(r => _userExpandedRoles.Contains(r));
    }

    private IEnumerable<RegisteredSubjectProperty> GetChildProperties()
    {
        if (_registeredSubject == null)
            return [];

        return _registeredSubject.Properties
            .Where(p => !p.IsAttribute && HasChildSubjects(p))
            .OrderBy(p => p.GetDisplayPosition());
    }

    private void TogglePropertyExpanded(string propertyName)
    {
        if (!_expandedProperties.Remove(propertyName))
            _expandedProperties.Add(propertyName);
    }

    private RenderFragment RenderProperty(RegisteredSubjectProperty prop, int depth) => __builder =>
    {
        // Property reads are automatically recorded via the context-based ReadPropertyRecorder
        var value = prop.GetValue();
        var attributes = prop.Attributes.ToArray();
        var hasAttributes = attributes.Length > 0;
        var isExpanded = _expandedProperties.Contains(prop.Name);
        var marginLeft = depth * 24;
        var displayName = prop.IsAttribute ? prop.AttributeMetadata.AttributeName : GetPropertyDisplayName(prop);
        var hasOverride = HasPropertyAuthorizationOverride(prop);
        var isReadOnly = !CanWriteProperty(prop);

        <MudText Style="@($"margin-left: {marginLeft}px; {(value is null ? "opacity: 0.5" : "")} {(isReadOnly ? "font-style: italic;" : "")}")">
            @if (hasAttributes)
            {
                <MudIconButton Icon="@(isExpanded ? Icons.Material.Filled.ArrowDropDown : Icons.Material.Filled.ArrowRight)"
                               Size="Size.Small"
                               Class="mr-1"
                               Style="padding: 0; width: 20px; height: 20px;"
                               OnClick="@(() => TogglePropertyExpanded(prop.Name))" />
            }
            else if (depth > 0)
            {
                <span style="display: inline-block; width: 24px;"></span>
            }
            <strong>@displayName: </strong>
            @prop.GetPropertyDisplayValue(value)
            <AuthorizeView Roles="Admin">
                <Authorized>
                    <MudTooltip Text="@(hasOverride ? "Authorization (Override)" : "Authorization")">
                        <MudIconButton Icon="@(hasOverride ? Icons.Material.Filled.Lock : Icons.Material.Outlined.Lock)"
                                       Size="Size.Small"
                                       Color="@(hasOverride ? Color.Warning : Color.Default)"
                                       Style="padding: 0; width: 16px; height: 16px; margin-left: 4px;"
                                       OnClick="@(() => OpenPropertyAuthorizationDialog(prop))" />
                    </MudTooltip>
                </Authorized>
            </AuthorizeView>
            @if (isReadOnly)
            {
                <MudTooltip Text="Read-only">
                    <MudIcon Icon="@Icons.Material.Filled.VisibilityOff" Size="Size.Small" Color="Color.Default" Style="margin-left: 4px; opacity: 0.5;" />
                </MudTooltip>
            }
        </MudText>

        @if (isExpanded)
        {
            foreach (var attr in attributes)
            {
                @RenderProperty(attr, depth + 1)
            }
        }
    };

    private string GetPropertyDisplayName(RegisteredSubjectProperty property)
    {
        return property.GetDisplayName();
    }

    private bool HasChildSubjects(RegisteredSubjectProperty property)
    {
        return property.HasChildSubjects;
    }

    private string GetSubjectDisplayName(SubjectPropertyChild child)
    {
        var subject = child.Subject;
        if (subject is ITitleProvider titleProvider && !string.IsNullOrEmpty(titleProvider.Title))
            return titleProvider.Title;

        return subject?.ToString() ?? "n/a";
    }

    private int GetChildCount(SubjectPropertyChild child)
    {
        var subject = child.Subject;
        var registered = SubjectRegistry?.TryGetRegisteredSubject(subject);
        if (registered == null) return 0;

        return registered.Properties
            .Where(p => !p.IsAttribute && HasChildSubjects(p))
            .Sum(p => GetFilteredChildren(p).Length);
    }

    private SubjectPropertyChild[] GetFilteredChildren(RegisteredSubjectProperty property)
    {
        return property.Children.Where(CanReadChildSubject).ToArray();
    }

    private bool CanReadChildSubject(SubjectPropertyChild child)
    {
        if (_userExpandedRoles == null)
            return true;

        var requiredRoles = AuthorizationResolver.ResolveSubjectRoles(
            child.Subject,
            AuthorizationEntity.State,
            AuthorizationAction.Read);

        return requiredRoles.Any(r => _userExpandedRoles.Contains(r));
    }

    private const string AuthorizationDataKeyPrefix = "HomeBlaze.Authorization:";

    private bool HasPropertyAuthorizationOverride(RegisteredSubjectProperty property)
    {
        if (Subject == null) return false;

        var entity = property.IsConfigurationProperty()
            ? AuthorizationEntity.Configuration
            : AuthorizationEntity.State;

        // Check for Read or Write override
        var readKey = $"{AuthorizationDataKeyPrefix}{entity}:{AuthorizationAction.Read}";
        var writeKey = $"{AuthorizationDataKeyPrefix}{entity}:{AuthorizationAction.Write}";

        return Subject.Data.ContainsKey((property.Name, readKey)) ||
               Subject.Data.ContainsKey((property.Name, writeKey));
    }

    private async Task OpenPropertyAuthorizationDialog(RegisteredSubjectProperty property)
    {
        if (Subject == null) return;

        var entity = property.IsConfigurationProperty()
            ? AuthorizationEntity.Configuration
            : AuthorizationEntity.State;

        var title = $"{GetSubjectTitle()} - {property.GetDisplayName()}";
        var parameters = new DialogParameters<SubjectAuthorizationPanel>
        {
            { x => x.Subject, Subject },
            { x => x.PropertyName, property.Name },
            { x => x.PropertyEntity, entity }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        await DialogService.ShowAsync<SubjectAuthorizationPanel>($"Authorization: {title}", parameters, options);
    }

    private bool HasMethodAuthorizationOverride(SubjectMethodInfo method)
    {
        if (Subject == null) return false;

        var entity = method.Kind == SubjectMethodKind.Query
            ? AuthorizationEntity.Query
            : AuthorizationEntity.Operation;

        var invokeKey = $"{AuthorizationDataKeyPrefix}{entity}:{AuthorizationAction.Invoke}";
        return Subject.Data.ContainsKey((method.MethodInfo.Name, invokeKey));
    }

    private async Task OpenMethodAuthorizationDialog(SubjectMethodInfo method)
    {
        if (Subject == null) return;

        var entity = method.Kind == SubjectMethodKind.Query
            ? AuthorizationEntity.Query
            : AuthorizationEntity.Operation;

        var title = $"{GetSubjectTitle()} - {method.Title}";
        var parameters = new DialogParameters<SubjectAuthorizationPanel>
        {
            { x => x.Subject, Subject },
            { x => x.MethodName, method.MethodInfo.Name },
            { x => x.MethodEntity, entity }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        await DialogService.ShowAsync<SubjectAuthorizationPanel>($"Authorization: {title}", parameters, options);
    }

    public record PropertyClickEventArgs(string PropertyName, object? Index, IInterceptorSubject Subject);

    private bool CanEdit()
    {
        if (Subject == null) return false;

        // Can edit if there's a custom edit component or configuration properties
        var hasEditComponent = ComponentRegistry.HasComponent(
            Subject.GetType(),
            SubjectComponentType.Edit);

        return hasEditComponent || Subject.HasConfigurationProperties();
    }

    private async Task OpenEditDialog()
    {
        if (Subject == null) return;

        var title = GetSubjectTitle();
        await SubjectEditDialog.ShowAsync(DialogService, ComponentRegistry, Subject, $"Edit {title}");
    }

    private async Task OpenAuthorizationDialog()
    {
        if (Subject == null) return;

        var title = GetSubjectTitle();
        var parameters = new DialogParameters<SubjectAuthorizationPanel>
        {
            { x => x.Subject, Subject }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        await DialogService.ShowAsync<SubjectAuthorizationPanel>($"Authorization: {title}", parameters, options);
    }

    private IReadOnlyList<SubjectMethodInfo> GetMethods()
    {
        var allMethods = _registeredSubject?.GetAllMethods() ?? [];

        // Filter methods based on user authorization
        if (Subject == null || _userExpandedRoles == null)
            return allMethods;

        return allMethods
            .Where(CanInvokeMethod)
            .ToList();
    }

    private bool CanInvokeMethod(SubjectMethodInfo method)
    {
        if (Subject == null || _userExpandedRoles == null)
            return true;

        var entity = method.Kind == SubjectMethodKind.Query
            ? AuthorizationEntity.Query
            : AuthorizationEntity.Operation;

        var requiredRoles = AuthorizationResolver.ResolveMethodRoles(Subject, entity, method.MethodInfo.Name);

        // Check if user has any of the required roles
        return requiredRoles.Any(r => _userExpandedRoles.Contains(r));
    }

    private async Task ExecuteMethodAsync(SubjectMethodInfo operation)
    {
        if (Subject == null || _executingOperation != null)
            return;

        try
        {
            object?[]? parameters = null;

            // Pre-resolve auto-injected and [FromServices] parameters
            var resolvedParameters = new Dictionary<string, object?>();
            foreach (var parameter in operation.Parameters)
            {
                if (SubjectMethodInvoker.IsAutoInjectedParameter(parameter.Type))
                {
                    resolvedParameters[parameter.Name] = null; // Placeholder, invoker will provide actual value
                    continue;
                }

                if (parameter.IsFromServices)
                {
                    resolvedParameters[parameter.Name] = ServiceProvider.GetService(parameter.Type);
                }
            }

            // Check if there are any parameters that need user input
            var needsParameterDialog = operation.Parameters.Length > resolvedParameters.Count;

            // If operation has parameters that need user input, show parameter dialog
            if (needsParameterDialog)
            {
                var parameterDialog = await MethodParameterDialog.ShowAsync(
                    DialogService, operation, resolvedParameters);
                var parameterResult = await parameterDialog.Result;
                if (parameterResult == null || parameterResult.Canceled)
                    return;

                parameters = parameterResult.Data as object?[];
            }
            // If all parameters were DI-resolved, build parameters array
            else if (resolvedParameters.Count > 0)
            {
                parameters = new object?[operation.Parameters.Length];
                for (var i = 0; i < operation.Parameters.Length; i++)
                {
                    var parameter = operation.Parameters[i];
                    parameters[i] = resolvedParameters[parameter.Name];
                }
            }
            // If operation requires confirmation, show confirmation dialog
            else if (operation.RequiresConfirmation)
            {
                var confirmDialog = await MethodConfirmationDialog.ShowAsync(DialogService, operation);
                var confirmResult = await confirmDialog.Result;
                if (confirmResult == null || confirmResult.Canceled)
                    return;
            }

            // Execute the operation
            _executingOperation = operation;
            StateHasChanged();

            var result = await MethodInvoker.InvokeAsync(
                Subject,
                operation,
                parameters ?? []);

            _executingOperation = null;
            StateHasChanged();

            // Show result or error dialog
            if (result.Success)
            {
                if (result.Result != null)
                {
                    await MethodResultDialog.ShowAsync(DialogService, operation.Title, result.Result);
                }
            }
            else
            {
                await MethodErrorDialog.ShowAsync(DialogService, operation.Title, result.Exception!);
            }
        }
        catch (Exception ex)
        {
            _executingOperation = null;
            await MethodErrorDialog.ShowAsync(DialogService, operation.Title, ex);
        }
    }
}
