@using HomeBlaze.Components
@using HomeBlaze.Storage.Abstractions
@using Toolbelt.Blazor.HotKeys2

@implements IAsyncDisposable

@inject RootManager RootManager
@inject SubjectComponentRegistry ComponentRegistry
@inject ISnackbar Snackbar
@inject DeveloperModeService DeveloperMode
@inject HotKeys HotKeys

<div style="@(Height != null ? $"height: {Height}; overflow-y: auto;" : "")">
    <TrackingScope Context="Subject?.Context" ShowDebugInfo="DeveloperMode.IsEnabled">
        @if (Subject != null)
        {
            @if (ComponentRegistry.HasComponent(Subject.GetType(), SubjectComponentType.Edit))
            {
                <SubjectComponent Subject="@Subject"
                                  Type="SubjectComponentType.Edit"
                                  @bind-ComponentInstance="_subjectComponent" />
            }
            else
            {
                <ConfigurationPropertiesEditor @ref="_propertiesEditor" Subject="@Subject" />
            }
        }
    </TrackingScope>
</div>

<div class="d-flex justify-end gap-2 mt-4">
    @if (ShowCancelButton)
    {
        <MudButton OnClick="@(() => OnCancel.InvokeAsync())">Cancel</MudButton>
    }

    <span data-testid="save-button">
        <MudButton Color="Color.Primary"
                   OnClick="SaveAsync"
                   Disabled="@(!IsValid)">Save (Ctrl+S)</MudButton>
    </span>
</div>

@code {
    [Parameter] public IInterceptorSubject? Subject { get; set; }

    [Parameter] public bool ShowCancelButton { get; set; }

    [Parameter] public string? Height { get; set; }

    [Parameter] public EventCallback OnCancel { get; set; }

    [Parameter] public EventCallback OnSaved { get; set; }

    private ISubjectComponent? _subjectComponent;
    private ISubjectEditComponent? _editComponent;
    private ConfigurationPropertiesEditor? _propertiesEditor;
    private HotKeysContext? _hotKeysContext;

    private bool IsValid => _editComponent?.IsValid ?? _propertiesEditor?.IsValid ?? true;

    protected override void OnInitialized()
    {
        _hotKeysContext = HotKeys.CreateContext()
            .Add(ModCode.Ctrl, Code.S, OnCtrlS, exclude: Exclude.None);
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Unsubscribe from previous edit component
        if (_editComponent != null)
        {
            _editComponent.IsValidChanged -= OnIsValidChanged;
            _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
            _editComponent = null;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        // Subscribe to new edit component if available
        if (_subjectComponent is ISubjectEditComponent editComponent && _editComponent != editComponent)
        {
            if (_editComponent != null)
            {
                _editComponent.IsValidChanged -= OnIsValidChanged;
                _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
            }

            _editComponent = editComponent;
            _editComponent.IsValidChanged += OnIsValidChanged;
            _editComponent.IsDirtyChanged += OnIsDirtyChanged;
            StateHasChanged();
        }
    }

    private void OnIsValidChanged(bool isValid) => InvokeAsync(StateHasChanged);

    private void OnIsDirtyChanged(bool isDirty) => InvokeAsync(StateHasChanged);

    private async Task OnCtrlS()
    {
        if (IsValid)
        {
            await SaveAsync();
        }
    }

    public async Task SaveAsync()
    {
        var subject = Subject;
        if (subject == null) return;

        try
        {
            if (_editComponent != null)
            {
                if (!_editComponent.IsValid)
                {
                    return;
                }

                await _editComponent.SaveAsync(CancellationToken.None);
            }
            else
            {
                if (_propertiesEditor?.HasErrors == true)
                {
                    return;
                }

                _propertiesEditor?.ApplyChanges();
            }

            if (subject is IConfigurationWriter configurationWriter)
            {
                var success = await configurationWriter.WriteConfigurationAsync(subject, CancellationToken.None);
                if (success)
                     await RootManager.WriteConfigurationAsync(subject, CancellationToken.None);
            }

            if (subject is IStorageFile storageFile)
            {
                await storageFile.OnFileChangedAsync(CancellationToken.None);
            }

            Snackbar.Add("File saved.", Severity.Info);
            await OnSaved.InvokeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving configuration: {ex.Message}", Severity.Error);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_editComponent != null)
        {
            _editComponent.IsValidChanged -= OnIsValidChanged;
            _editComponent.IsDirtyChanged -= OnIsDirtyChanged;
        }

        if (_hotKeysContext != null)
        {
            await _hotKeysContext.DisposeAsync();
        }
    }
}
